local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/refs/heads/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()
local Options = Library.Options
local Toggles = Library.Toggles
Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

local function print_colored(t, c)
    if c == "red" then
        warn("[ERROR] " .. t)
    elseif c == "yellow" then
        warn("[WARN] " .. t)
    else
        print(t)
    end
end

local ascii = [[
____   ____     .__                .__  __           ____  ___
\   \ /   /____ |  |   ____   ____ |__|/  |_ ___.__. \   \/  /
 \   Y   // __ \|  |  /  _ \_/ ___\|  \   __<   |  |  \     /
  \     /\  ___/|  |_(  <_> )  \___|  ||  |  \___  |  /     \
   \___/  \___  >____/\____/ \___  >__||__|  / ____| /___/\  \
              \/                 \/          \/            \_/
]]

local function getGlobal(p)
    local v = getfenv(0)
    while v ~= nil and p ~= "" do
        local n, nxt = string.match(p, "^([^.]+)%.?(.*)$")
        v = v[n]
        p = nxt
    end
    return v
end

loadstring(game:HttpGet("https://raw.githubusercontent.com/Saersa/Fun_Scripts/refs/heads/main/Console_Rich_Text.lua"))()

local function testFunction(n, f)
    local e = getGlobal(n) ~= nil
    local c = e and "rgb(0,255,0)" or "rgb(255,0,0)"
    print(string.format('<font color="%s">%s</font>', c, n))
    if not e then
        table.insert(f, n)
    end
end

local requiredFunctions = {
    "checkcaller","cloneref","clonefunction","hookfunction","hookmetamethod","getnamecallmethod",
    "newcclosure","loadstring","request","setthreadidentity","getthreadidentity","setclipboard",
    "setfpscap","getgc","getloadedmodules","getnilinstances","getscripts","getrunningscripts",
    "getsenv","getrenv","fireclickdetector","gethui","gethiddenproperty","sethiddenproperty",
    "isscriptable","setscriptable","getrawmetatable","setrawmetatable","isreadonly","setreadonly",
    "getcallbackvalue","getconnections","isrbxactive","readfile","writefile","isfile","isfolder",
    "makefolder","delfolder","delfile","appendfile","listfiles","crypt.encrypt","crypt.decrypt",
    "crypt.hash","crypt.base64encode","crypt.base64decode","crypt.generatekey","crypt.generatebytes"
}

print_colored(ascii, "green")
print("\nChecking required functions...\n")

local failedFunctions = {}
for _, func in ipairs(requiredFunctions) do
    testFunction(func, failedFunctions)
end

local Unsupported = {}
for _, func in ipairs(failedFunctions) do
    Unsupported[func] = true
end

if #failedFunctions > 0 then
    local msg = "Unsupported functions: " .. table.concat(failedFunctions, ", ") .. ". Some features may not work."
    Library:Notify(msg, 6)
else
    Library:Notify("All required functions supported", 3)
end

print_colored("Script Loaded", "green")

local function safeAddCheckbox(g, i, d, r)
    if r and Unsupported[r] then
        d.Disabled = true
        d.Text = d.Text .. " (Unsupported)"
    end
    return g:AddCheckbox(i, d)
end

local function safeAddSlider(g, i, d, r)
    if r and Unsupported[r] then
        d.Disabled = true
        d.Text = d.Text .. " (Unsupported)"
    end
    return g:AddSlider(i, d)
end

local function safeAddDropdown(g, i, d, r)
    if r and Unsupported[r] then
        d.Disabled = true
        d.Text = d.Text .. " (Unsupported)"
    end
    return g:AddDropdown(i, d)
end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local GameData = ReplicatedStorage:WaitForChild("GameData")
local currentFloor = GameData:WaitForChild("Floor").Value

local Window = Library:CreateWindow({
    Title = "Ostium",
    Footer = "v2.10 | Ostium | Floor: " .. currentFloor,
    Icon = 117198211193045,
    NotifySide = "Right",
    ShowCustomCursor = false,
    EnableSidebarResize = true,
    SidebarMinWidth = 200, 
    SidebarCompactWidth = 56,
    SidebarCollapseThreshold = 0.45, 
})

local Tabs = {
Home = Window:AddTab("Start", "house"),
Player = Window:AddTab("Player", "user"),
Misc = Window:AddTab("Misc", "box"),
Visuals = Window:AddTab("Visuals", "eye"),
Entities = Window:AddTab("Floor", "chevrons-left-right"),
}


local HomeGroup = Tabs.Home:AddLeftGroupbox("Welcome")

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local avatarImage = HomeGroup:AddImage("AvatarThumbnail", {
    Image = "rbxassetid://0",
    Callback = function(image)
        print("Image changed!", image)
    end,
})

task.spawn(function()
    repeat task.wait() until player

    task.wait(1)

    local success, thumbnail = pcall(function()
        return Players:GetUserThumbnailAsync(
            player.UserId,
            Enum.ThumbnailType.HeadShot,
            Enum.ThumbnailSize.Size180x180
        )
    end)

    if success and thumbnail then
        avatarImage:SetImage(thumbnail)
    else
        local alternatives = {
            Enum.ThumbnailType.AvatarThumbnail,
            Enum.ThumbnailType.AvatarBust,
            Enum.ThumbnailType.Avatar,
        }

        for _, thumbnailType in ipairs(alternatives) do
            local altSuccess, altThumbnail = pcall(function()
                return Players:GetUserThumbnailAsync(
                    player.UserId,
                    thumbnailType,
                    Enum.ThumbnailSize.Size180x180
                )
            end)

            if altSuccess and altThumbnail then
                avatarImage:SetImage(altThumbnail)
                break
            end
        end
    end
end)





HomeGroup:AddLabel((function() local h=os.date("*t").hour return (h<12 and h>=5 and "Good morning" or h<17 and "Good afternoon" or h<21 and "Good evening" or "Good night") end)() .. ", " .. game.Players.LocalPlayer.Name)


HomeGroup:AddDivider()


HomeGroup:AddButton("Join Discord", function()
    setclipboard("https://discord.gg/9UuswyPTDE")
    Library:Notify("Discord link copied to clipboard!")
end)
HomeGroup:AddButton("Website", function()
    setclipboard("https://getvelocityx.netlify.app/")
    Library:Notify("website link copied to clipboard!")
end)


Tabs.Home:UpdateWarningBox({
    Title = "Changelogs",
    Text = [[
<font color="rgb(76, 0, 255)">Release v2.10</font>

<font color="rgb(255, 255, 255)">-- Visuals & ESP --</font>
- <font color="rgb(0, 255, 0)">Added Candy ESP</font>
- <font color="rgb(0, 255, 0)">Added CandyBag ESP</font>
- <font color="rgb(0, 255, 0)">Added House ESP</font>

<font color="rgb(255, 255, 255)">-- Main --</font>
- <font color="rgb(0, 255, 0)">Remade No Fog to work with Halloween update</font>

<font color="rgb(255, 255, 255)">-- Fixes --</font>
- <font color="rgb(255, 165, 0)">Fixed Key Link</font>

<font color="rgb(255, 0, 0)">-- Performance --</font>
- <font color="rgb(255, 165, 0)">Reduced FPS drop issues</font>
    ]],
    IsNormal = true,
    Visible = true,
    LockSize = true
})



local StatusGroup = Tabs.Home:AddRightGroupbox("Status")

local HttpService = game:GetService("HttpService")
local fileName = "Ostium/ostium_executions.json"
local count = 0

if isfile(fileName) then
    local success, data = pcall(function()
        return HttpService:JSONDecode(readfile(fileName))
    end)
    if success and data.count then
        count = data.count
    end
end

count = count + 1

pcall(function()
    writefile(fileName, HttpService:JSONEncode({count = count}))
end)

local ExecutionLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">Total Executions: ' .. count .. '</font>')




StatusGroup:AddDivider()


local VolcanoLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">游릭 Volcano</font>')
local DeltaLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">游릭 Delta</font>')
local SwiftLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">游릭 Swift</font>')
local ValexLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">游릭 Valex</font>')
local VelocityLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">游릭 Velocity</font>')
local KRNLLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">游릭 KRNL</font>')
local SolaraLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">游릭 Solara</font>')
local XenoLabel = StatusGroup:AddLabel('<font color="rgb(0,255,255)">游릭 Xeno</font>')











local LocalPlayer = game.Players.LocalPlayer
local Rooms = workspace.CurrentRooms
local Unloaded = false
local ClonedCollision
local OldAccel = LocalPlayer.Character.HumanoidRootPart.CustomPhysicalProperties
local AntiConnections = {}
local oldBrightness = game.Lighting.Brightness
local oldClockTime = game.Lighting.ClockTime
local oldFogEnd = game.Lighting.FogEnd
local oldGlobalShadows = game.Lighting.GlobalShadows
local oldAmbient = game.Lighting.Ambient











local GodmodeStuff = Tabs.Player:AddLeftGroupbox('Godmode')



local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local lp = Players.LocalPlayer

local Toggles, Options = Library.Toggles, Library.Options
local AutoMode, PrevMode, AutoDistance = "Toggle", "Toggle", 166
local ActiveEntities, EntList = {}, { "a60", "ambushmoving", "backdoorrush", "rushmoving", "mandrake" }

local function setGodmode(state)
    local char = lp.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local col = char:FindFirstChild("Collision")
    if not (hum and col) then return end

    hum.HipHeight = state and 0.09 or 2.4
    local size = state and Vector3.new(1, 3, 3) or Vector3.new(5.5, 3, 3)
    col.Size = size
    local crouch = col:FindFirstChild("CollisionCrouch")
    if crouch then crouch.Size = size end
end

local function safeDisableGod()
    local char = lp.Character
    if not char then return end
    local hum, col = char:FindFirstChildOfClass("Humanoid"), char:FindFirstChild("Collision")
    if not (hum and col) then
        setGodmode(false)
        return
    end

    if AutoMode ~= "Never" and Toggles.Noclip and not Toggles.Noclip.Value then
        Toggles.Noclip:SetValue(true)
        task.delay(0.2, function()
            if Toggles.Noclip and Toggles.Noclip.Value then
                Toggles.Noclip:SetValue(false)
            end
        end)
    end

    setGodmode(false)
end

GodmodeStuff:AddDropdown("GodmodeMode", {
    Text = "Godmode",
    Default = "Toggle",
    Values = {"Toggle","Automatic","Hold","Always"},
    Callback = function(mode)
        if PrevMode == "Always" and mode ~= "Always" then
            if Toggles.PositionSpoof and Toggles.PositionSpoof.Value then
                Toggles.PositionSpoof:SetValue(false)
                setGodmode(false)
                if Toggles.Noclip and not Toggles.Noclip.Value then
                    Toggles.Noclip:SetValue(true)
                    task.delay(0.2,function()
                        if Toggles.Noclip and Toggles.Noclip.Value then
                            Toggles.Noclip:SetValue(false)
                        end
                    end)
                end
            end
        end
        AutoMode, PrevMode = mode, mode
        if Options.PositionSpoofKey then
            Options.PositionSpoofKey.Text = "Position Spoof ("..mode..")"
        end
        if mode == "Always" then
            Toggles.PositionSpoof:SetValue(true)
        elseif mode == "Never" then
            Toggles.PositionSpoof:SetValue(false)
        end
    end
})

GodmodeStuff:AddCheckbox("PositionSpoof", {
    Text = "Godmode Toggle",
    Default = false,
    Callback = function(v)
        if v then
            setGodmode(true)
            if Toggles.AntiFigure and not Toggles.AntiFigure.Value then
                Toggles.AntiFigure:SetValue(true)
                Library:Notify({
                    Title="Godmode Enabled",
                    Description="AntiFigure enabled automatically.",
                    Duration=5,
                    Color=Color3.fromRGB(0,200,255)
                })
            end
        else
            safeDisableGod()
            if Toggles.AntiFigure and Toggles.AntiFigure.Value then
                Toggles.AntiFigure:SetValue(false)
                Library:Notify({
                    Title="Godmode Disabled",
                    Description="AntiFigure disabled automatically.",
                    Duration=5,
                    Color=Color3.fromRGB(255,128,128)
                })
            end
        end
    end
}):AddKeyPicker("PositionSpoofKey",{
    Default="K",
    Mode="Toggle",
    Text="Position Spoof (Toggle)",
    SyncToggleState=true
})

-- Cache lowercase list for faster lookup
local ValidNames = {}
for _,v in ipairs(EntList) do ValidNames[v] = true end

workspace.DescendantAdded:Connect(function(obj)
    if ValidNames[obj.Name:lower()] then
        local part = obj:FindFirstChildWhichIsA("BasePart")
        if part then ActiveEntities[obj] = part end
    end
end)

RunService.Heartbeat:Connect(function()
    if not lp.Character or getgenv().Library.Unloaded then return end
    local root = lp.Character:FindFirstChild("HumanoidRootPart")
    if not root then return end

    if AutoMode == "Automatic" then
        local enabled
        for ent,part in pairs(ActiveEntities) do
            if not ent.Parent then
                ActiveEntities[ent] = nil
            elseif (root.Position - part.Position).Magnitude < AutoDistance then
                enabled = true
                break
            end
        end
        local spoof = Toggles.PositionSpoof.Value
        if enabled and not spoof then
            Toggles.PositionSpoof:SetValue(true)
        elseif not enabled and spoof then
            Toggles.PositionSpoof:SetValue(false)
            safeDisableGod()
        end
    elseif AutoMode == "Hold" then
        local key = Options.PositionSpoofKey and Options.PositionSpoofKey.Value
        local pressed = key and UserInputService:IsKeyDown(key)
        local spoof = Toggles.PositionSpoof.Value
        if pressed and not spoof then
            Toggles.PositionSpoof:SetValue(true)
        elseif not pressed and spoof then
            Toggles.PositionSpoof:SetValue(false)
            safeDisableGod()
        end
    elseif AutoMode == "Always" then
        if not Toggles.PositionSpoof.Value then
            Toggles.PositionSpoof:SetValue(true)
        end
    elseif AutoMode == "Never" then
        if Toggles.PositionSpoof.Value then
            Toggles.PositionSpoof:SetValue(false)
        end
    end
end)

-- keep godmode applied while enabled, low-frequency loop
task.spawn(function()
    while task.wait(0.25) do
        if getgenv().Library.Unloaded then break end
        if Toggles.PositionSpoof and Toggles.PositionSpoof.Value then
            setGodmode(true)
        end
    end
end)





local MovementGroup = Tabs.Player:AddRightGroupbox("Walkspeed")









local LocalPlayer = game.Players.LocalPlayer
local Unloaded = false
local ClonedCollision
local OldAccel = PhysicalProperties.new(0.01, 0.7, 0, 1, 1)

if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("CollisionPart") then
    ClonedCollision = LocalPlayer.Character.CollisionPart:Clone()
    ClonedCollision.Name = "_CollisionClone"
    ClonedCollision.Massless = true
    ClonedCollision.Parent = LocalPlayer.Character
    ClonedCollision.CanCollide = false
    ClonedCollision.CanQuery = false
    ClonedCollision.CustomPhysicalProperties = OldAccel
end
LocalPlayer.CharacterAdded:Connect(function()
task.wait(1.5)

if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("CollisionPart") then
    ClonedCollision = LocalPlayer.Character.CollisionPart:Clone()
    ClonedCollision.Name = "_CollisionClone"
    ClonedCollision.Massless = true
    ClonedCollision.Parent = LocalPlayer.Character
    ClonedCollision.CanCollide = false
    ClonedCollision.CanQuery = false
    ClonedCollision.CustomPhysicalProperties = OldAccel
end


end)

task.spawn(function()
    while task.wait(0.23) and not Unloaded do
        if Toggles.WalkspeedModifier.Value and Options.WalkspeedAmount.Value > 21 and ClonedCollision then
            ClonedCollision.Massless = false
            task.wait(0.23)
            if LocalPlayer.Character 
            and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") 
            and LocalPlayer.Character.HumanoidRootPart.Anchored then
                ClonedCollision.Massless = true
                task.wait(1)
            end
            ClonedCollision.Massless = true
        end
    end
end)

 BypassLabel = MovementGroup:AddLabel('<font color="rgb(255,0,0)">Speed Bypass: Inactive</font>')

 function updateBypassLabel()
    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
         realSpeed = humanoid.WalkSpeed
        local active = realSpeed > 21
        local color = active and "0,255,0" or "255,0,0"
         status = active and "Active" or "Inactive"
        BypassLabel:SetText('<font color="rgb(' .. color .. ')">Speed Bypass: ' .. status .. '</font>')
    end
end

task.spawn(function()
    while task.wait(0.1) and not Unloaded do
         humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            if Toggles.WalkspeedModifier.Value then
                humanoid.WalkSpeed = Options.WalkspeedAmount.Value
            end
            updateBypassLabel()
        end
    end
end)

MovementGroup:AddDivider()

 function bindHumanoid(humanoid)
    humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(updateBypassLabel)
end

MovementGroup:AddCheckbox("WalkspeedModifier", {
    Text = "Custom Walk Speed",
    Default = false,
    Disabled = false,
    Tooltip = "Changes your walking speed to the set value.",
    Callback = function(Value)
        updateBypassLabel()
    end
})

MovementGroup:AddCheckbox("NoAcceleration", {
    Text = "Instant Acceleration",
    Default = false,
    Disabled = false,
    Tooltip = "Removes slow-down when changing direction.",
    Callback = function(Value)
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.CustomPhysicalProperties = Value and PhysicalProperties.new(100, 0, 0, 0, 0) or OldAccel
        end
    end
})


MovementGroup:AddSlider("WalkspeedAmount", {
    Text = "Walk Speed Value",
    Default = 21,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Compact = true,
    Tooltip = "Sets how fast you walk.",
    Callback = function(Value)
        updateBypassLabel()
    end
})

LocalPlayer.CharacterAdded:Connect(function(character)
    local humanoid = character:WaitForChild("Humanoid")
    bindHumanoid(humanoid)
    updateBypassLabel()
end)

if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
    bindHumanoid(LocalPlayer.Character.Humanoid)
end

updateBypassLabel()







 MovementGroupZ = Tabs.Player:AddLeftGroupbox("Movement")

MovementGroupZ:AddCheckbox("AlwaysJump", { Text = "Enable Jump", Default = false, Disabled = false, Tooltip = "Lets you jump anytime.", Callback = function(Value)
    LocalPlayer.Character:SetAttribute("CanJump", Value or CanJump)
end })

MovementGroupZ:AddCheckbox("AlwaysSlide", { Text = "Enable Slide", Default = false, Disabled = false, Tooltip = "Lets you slide anytime.", Callback = function(Value)
    LocalPlayer.Character:SetAttribute("CanSlide", Value or CanJump)
end })

 isFlying = false
 flyConnections = {}
 keys = {W = false, A = false, S = false, D = false, Space = false, Shift = false}
 FlySpeed = 50 

 function startFly()
     player = game.Players.LocalPlayer
     character = player.Character
    if not character then return end
     humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

     bv = Instance.new("BodyVelocity")
    bv.Name = "FlyVelocity"
    bv.MaxForce = Vector3.new(1e9, 1e9, 1e9)  
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.Parent = hrp

     bg = Instance.new("BodyGyro")
    bg.Name = "FlyGyro"
    bg.MaxTorque = Vector3.new(1e9, 1e9, 1e9)
    bg.P = 20000 
    bg.D = 1000  
    bg.Parent = hrp

    humanoid.AutoRotate = false
    humanoid.PlatformStand = true
    humanoid:ChangeState(Enum.HumanoidStateType.Physics)

     inputBegan = game:GetService("UserInputService").InputBegan:Connect(function(input, gpe)
        if gpe then return end
        if input.KeyCode == Enum.KeyCode.W then keys.W = true
        elseif input.KeyCode == Enum.KeyCode.A then keys.A = true
        elseif input.KeyCode == Enum.KeyCode.S then keys.S = true
        elseif input.KeyCode == Enum.KeyCode.D then keys.D = true
        elseif input.KeyCode == Enum.KeyCode.Space then keys.Space = true
        elseif input.KeyCode == Enum.KeyCode.LeftShift then keys.Shift = true end
    end)
    table.insert(flyConnections, inputBegan)

    local inputEnded = game:GetService("UserInputService").InputEnded:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.W then keys.W = false
        elseif input.KeyCode == Enum.KeyCode.A then keys.A = false
        elseif input.KeyCode == Enum.KeyCode.S then keys.S = false
        elseif input.KeyCode == Enum.KeyCode.D then keys.D = false
        elseif input.KeyCode == Enum.KeyCode.Space then keys.Space = false
        elseif input.KeyCode == Enum.KeyCode.LeftShift then keys.Shift = false end
    end)
    table.insert(flyConnections, inputEnded)

    local renderConnection = game:GetService("RunService").RenderStepped:Connect(function()
        local cam = workspace.CurrentCamera
        if not cam or not hrp or not hrp:FindFirstChild("FlyVelocity") or not humanoid or humanoid.Health <= 0 then
            stopFly()
            return
        end

        local move = Vector3.new(0, 0, 0)
        if keys.W then move = move + cam.CFrame.LookVector end
        if keys.S then move = move - cam.CFrame.LookVector end
        if keys.A then move = move - cam.CFrame.RightVector end
        if keys.D then move = move + cam.CFrame.RightVector end
        if keys.Space then move = move + Vector3.new(0, 1, 0) end
        if keys.Shift then move = move - Vector3.new(0, 1, 0) end

        local direction = (move.Magnitude > 0) and (move.Unit * FlySpeed) or Vector3.new(0, 0, 0)
        bv.Velocity = direction

        bg.CFrame = cam.CFrame
    end)
    table.insert(flyConnections, renderConnection)
end

local function stopFly()
    local player = game.Players.LocalPlayer
    local character = player.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    local hrp = character and character:FindFirstChild("HumanoidRootPart")

    if hrp then
        local flyVelocity = hrp:FindFirstChild("FlyVelocity")
        if flyVelocity then flyVelocity:Destroy() end
        local flyGyro = hrp:FindFirstChild("FlyGyro")
        if flyGyro then flyGyro:Destroy() end
    end

    if humanoid then
        humanoid.AutoRotate = true
        humanoid.PlatformStand = false
        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
    end

    for _, conn in ipairs(flyConnections) do
        conn:Disconnect()
    end
    flyConnections = {}

    keys = {W = false, A = false, S = false, D = false, Space = false, Shift = false}
end

MovementGroupZ:AddCheckbox("Fly", {
    Text = "Fly",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        isFlying = Value
        if Value then
            startFly()
        else
            stopFly()
        end
    end
}):AddKeyPicker("FlyKeybind", {
    Default = "F",
    SyncToggleState = true, 
    Mode = "Toggle", 
    Text = "Fly Toggle", 
    NoUI = false, 

    Callback = function(Value)
    end,
})














local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local lp = Players.LocalPlayer
local noclipConnection
local originalGroups = {}

local function enableNoclip()
    if noclipConnection then return end
    noclipConnection = RunService.Stepped:Connect(function()
        if lp.Character then
            for _, part in pairs(lp.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                    if not originalGroups[part] then
                        originalGroups[part] = part.CollisionGroup
                    end
                    part.CollisionGroup = "Default"
                end
            end
        end
    end)
end

local function disableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end

    local char = lp.Character
    if not char then return end

    local collision = char:FindFirstChild("Collision")
    local crouch = collision and collision:FindFirstChild("CollisionCrouch")

    if collision and crouch then
        local crouching = (collision.CollisionGroup == "PlayerCrouching")
        collision.CanCollide = not crouching
        crouch.CanCollide = crouching
    end
end

MovementGroupZ:AddCheckbox("Noclip", {
    Text = "Noclip",
    Default = false,
    Disabled = false,
    Tooltip = "you know what it does",
    Callback = function(Value)
        if Value then
            enableNoclip()
        else
            disableNoclip()
        end
    end,
}):AddKeyPicker("NoclipKeybind", {
    Default = "N",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Noclip Toggle",
    NoUI = false,
    Callback = function(Value)
    end,
})


















game.Players.LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    if isFlying then
        newCharacter:WaitForChild("HumanoidRootPart")
        newCharacter:WaitForChild("Humanoid")
        startFly()
    end
end)

game.Players.LocalPlayer.CharacterRemoving:Connect(function()
    if isFlying then
        stopFly()
    end
end)



local RunService = game:GetService("RunService")

MovementGroupZ:AddCheckbox("LadderSpeedBoost", {
    Text = "Faster Ladder Climb",
    Default = false,
    Disabled = false,
    Callback = function(on)
        if on then
            AntiConnections.LadderBoost = RunService.Heartbeat:Connect(function()
                local char = LocalPlayer.Character
                local hum = char and char:FindFirstChildOfClass("Humanoid")
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                if hum and hrp and hum:GetState() == Enum.HumanoidStateType.Climbing then
                    hrp.Velocity = Vector3.new(hrp.Velocity.X, Options.LadderSpeedBoostAmount.Value, hrp.Velocity.Z)
                end
            end)
        else
            if AntiConnections.LadderBoost then
                AntiConnections.LadderBoost:Disconnect()
                AntiConnections.LadderBoost = nil
            end
        end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local UserInputService = game:GetService("UserInputService")

local savedCamCFrame
local camLocked = false
local acmButton
local acmButtonActive = false

local BUTTON_SIZE = UDim2.new(0, 70, 0, 35)
local BUTTON_POSITION = UDim2.new(1, -80, 0.5, -17)
local BUTTON_COLOR = Color3.fromRGB(45, 45, 45)
local BUTTON_ACTIVE_COLOR = Color3.fromRGB(90, 90, 90)
local BUTTON_TEXT_COLOR = Color3.fromRGB(255, 255, 255)

MovementGroupZ:AddCheckbox("AntiCheatManipulation", {
	Text = "Anti-Cheat Manipulation",
	Default = false,
}):AddKeyPicker("AntiCheatManipulation_K", {
	Default = "T",
	Mode = "Hold",
	Text = "Anti-Cheat Manipulation",
})

local function createACMButton()
	if not UserInputService.TouchEnabled or acmButton then return end
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "ACMGui"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = PlayerGui

	local button = Instance.new("TextButton")
	button.Name = "ACMButton"
	button.Size = BUTTON_SIZE
	button.Position = BUTTON_POSITION
	button.BackgroundColor3 = BUTTON_COLOR
	button.Text = "ACM"
	button.TextColor3 = BUTTON_TEXT_COLOR
	button.Font = Enum.Font.GothamBold
	button.TextSize = 16
	button.BorderSizePixel = 0
	button.Parent = screenGui

	button.MouseButton1Down:Connect(function()
		acmButtonActive = true
		button.BackgroundColor3 = BUTTON_ACTIVE_COLOR
	end)

	button.MouseButton1Up:Connect(function()
		acmButtonActive = false
		button.BackgroundColor3 = BUTTON_COLOR
	end)

	acmButton = screenGui
end

local function removeACMButton()
	if acmButton then
		acmButton:Destroy()
		acmButton = nil
		acmButtonActive = false
	end
end

Toggles.AntiCheatManipulation:OnChanged(function()
	if Toggles.AntiCheatManipulation.Value then
		createACMButton()
	else
		removeACMButton()
	end
end)

RunService.RenderStepped:Connect(function()
	local cam = workspace.CurrentCamera
	if not cam then return end
	local active = (Toggles.AntiCheatManipulation.Value and Options.AntiCheatManipulation_K:GetState()) or acmButtonActive
	local char = LocalPlayer.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if active and hrp then
		if not camLocked then
			savedCamCFrame = cam.CFrame
			cam.CameraType = Enum.CameraType.Scriptable
			camLocked = true
			hrp.CFrame = hrp.CFrame * CFrame.new(0, 0, 10000)
		end
		cam.CFrame = savedCamCFrame
	else
		if camLocked then
			cam.CameraType = Enum.CameraType.Custom
			camLocked = false
			savedCamCFrame = nil
		end
	end
end)



MovementGroupZ:AddSlider("LadderSpeedBoostAmount", {
    Text = "Ladder Climb Speed",
    Default = 20,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Compact = true,
    Tooltip = "Boost for climbing ladders. Higher values might be unstable."
})


local FlySpeed = 50

MovementGroupZ:AddSlider("Fly Speed", {
    Text = "Fly Speed",
    Default = FlySpeed,
    Min = 0,
    Max = 150,
    Rounding = 0,
    Compact = true,
    Tooltip = "Change fly speed",
    Callback = function(Value)
        FlySpeed = Value
    end
})



local BypassGroupp = Tabs.Player:AddRightGroupbox("Bypass")


BypassGroupp:AddCheckbox('AnticheatBypass', {
    Text = "Anticheat Bypass",
    Default = false
})

Toggles.AnticheatBypass:OnChanged(function(Value)
    if not Value then
        RemoteFolder.ClimbLadder:FireServer()
    else
        Library:Notify("get on a ladder", 9)
    end
end)
LocalPlayer.Character:GetAttributeChangedSignal("Climbing"):Connect(function()
    if Toggles.AnticheatBypass.Value and LocalPlayer.Character:GetAttribute("Climbing") == true then
        task.spawn(function()
            task.wait(0.1) 
            LocalPlayer.Character:SetAttribute("Climbing", false)
            Library:Notify("Bypassed anticheat, climb reset", 7)
        end)
    end
end)



local AutomationGroup = Tabs.Player:AddRightGroupbox("Automation")local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

local running = false

AutomationGroup:AddCheckbox("AnchorCodeSolver", {
	Text = "Anchor Code Solver",
	Default = false,
	Disabled = false,
	Callback = function(enabled)
		if enabled then
			if running then return end
			running = true

			task.spawn(function()
				local playerGui = LocalPlayer:WaitForChild("PlayerGui")

				local function findFrame()
					local mainUI = playerGui:FindFirstChild("MainUI")
					if mainUI and mainUI:FindFirstChild("MainFrame") then
						local frame = mainUI.MainFrame:FindFirstChild("AnchorHintFrame")
						if frame then
							return frame
						end
					end

					local anchorUI = playerGui:FindFirstChild("AnchorHintUI")
					if anchorUI then
						local frame = anchorUI:FindFirstChild("AnchorHintFrame")
						if frame then
							return frame
						end
					end

					return nil
				end

				while running do
					task.wait(0.9)

					local frame = findFrame()
					if frame then
						local anchorName = frame:FindFirstChild("AnchorCode") and frame.AnchorCode.Text or ""
						local codeText = frame:FindFirstChild("Code") and frame.Code.Text or ""

						if anchorName ~= "" and codeText ~= "" then
							local anchorObject

							for _, obj in ipairs(Workspace.CurrentRooms:GetDescendants()) do
								if obj.Name == "MinesAnchor" then
									local sign = obj:FindFirstChild("Sign")
									if sign then
										local label = sign:FindFirstChild("TextLabel") or sign:FindFirstChildWhichIsA("TextLabel")
										if label and label.Text == anchorName then
											anchorObject = obj
											break
										end
									end
								end
							end

							if anchorObject then
								local note = anchorObject:FindFirstChild("Note")

								if not note then
									Library:Notify(string.format("Anchor %s Code is %s", anchorName, codeText), 3)
								else
									local surfaceGui = note:FindFirstChildOfClass("SurfaceGui") or note:FindFirstChild("SurfaceGui")
									local noteText = surfaceGui and surfaceGui:FindFirstChild("TextLabel") and surfaceGui.TextLabel.Text or "0"
									local noteValue = tonumber(noteText) or 0

									local solved = ""
									for i = 1, #codeText do
										local digit = tonumber(codeText:sub(i, i)) or 0
										digit = (digit + noteValue) % 10
										solved = solved .. tostring(digit)
									end

									Library:Notify(string.format("Anchor %s Code is %s", anchorName, solved), 5)
								end
							end
						end
					else
						task.wait(0.25)
					end
				end
			end)
		else
			running = false
		end
	end
})






local Players = game:GetService("Players")
local VirtualUser = game:GetService("VirtualUser")
local LocalPlayer = Players.LocalPlayer

local AntiAFKConnection

AutomationGroup:AddCheckbox("AntiAFK", {
    Text = "Anti AFK",
    Visible = (getconnections ~= nil),
    Default = false,
    Disabled = false,
    Callback = function(Value)
        if Value then
            AntiAFKConnection = LocalPlayer.Idled:Connect(function()
                VirtualUser:CaptureController()
                VirtualUser:ClickButton2(Vector2.new())
            end)
        else
            if AntiAFKConnection then
                AntiAFKConnection:Disconnect()
                AntiAFKConnection = nil
            end
        end
    end
})

local Script = {}
Script.Functions = {}
Script.Temp = {}
Script.PromptTable = {}
Script.PromptTable.GamePrompts = {}
shared.Connections = {}



local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

local Breaker = nil
local RemoteFolder = ReplicatedStorage:FindFirstChild("RemotesFolder") 
    or ReplicatedStorage:FindFirstChild("EntityInfo") 
    or ReplicatedStorage:FindFirstChild("Bricks")




AutomationGroup:AddCheckbox("FastClosetExit", {
	Text = "Fast Closet Exit",
	Visible = true,
	Default = false,
	Disabled = false,
	Callback = function(Value)
		if Value then
			task.spawn(function()
				while Value do
					task.wait()
					for _, b in pairs(game:GetService("Players"):GetPlayers()) do
						if b.Character and b.Character:GetAttribute("Hiding") == true then
							local V = b.Character
							if V:FindFirstChild("Humanoid") and V.Humanoid.MoveDirection.Magnitude > 0.5 then
								game.ReplicatedStorage.RemotesFolder.CamLock:FireServer()
							end
						end
					end
				end
			end)
		end
	end
})



AutomationGroup:AddCheckbox("AutoPuzzleRoom", {
	Text = "Auto Puzzle Room",
	Visible = true,
	Default = false,
	Disabled = false,
	Callback = function(Value)
		if not Value then return end

		local RunService = game:GetService("RunService")
		local CurrentRooms = workspace:WaitForChild("CurrentRooms")
		local lastChecked = 0

		local function deleteMovingDoors(parent)
			for _, obj in ipairs(parent:GetDescendants()) do
				if obj:IsA("Model") and obj.Name == "MovingDoor" then
					obj:Destroy()
				end
			end
		end

		RunService.Heartbeat:Connect(function(dt)
			lastChecked = lastChecked + dt
			if lastChecked >= 1 then 
				deleteMovingDoors(CurrentRooms)
				lastChecked = 0
			end
		end)
	end
})





AutomationGroup:AddCheckbox("AutoBreakerSolver", {
    Text = "Solve Breaker Minigame",
    Default = false,
    Disabled = false,
    Callback = function(Value)
               while task.wait() do
                   if not Toggles.AutoBreakerSolver.Value then break end

            local currentRoom = LocalPlayer:GetAttribute("CurrentRoom")
                        if currentRoom ~= 100 then
                        Library:Notify("You have to do this in room 100 otherwise your FPS goes in the -'s", 5)
                break
            end

                      Breaker = nil
            for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
                                 if v.Name == "ElevatorBreaker" then
                    Breaker = v
                    break
                end
            end

            if Breaker then
            local solved = true
            for _, v in ipairs(Breaker:GetChildren()) do
            if v.Name == "BreakerSwitch" then
                                local codeText = Breaker:WaitForChild("SurfaceGui").Frame.Code.Text
                                            if v:GetAttribute("ID") == tonumber(codeText) then
                                        if Breaker.SurfaceGui.Frame.Code.Frame.BackgroundTransparency == 0 then
                                v:SetAttribute("Enabled", true)
                                if not v.Sound.Playing then
                                    v.Sound.Playing = true
                                       end
                                v.Material = Enum.Material.Neon
                                       v.Light.Attachment.Spark:Emit(1)
                                v.PrismaticConstraint.TargetPosition = -0.2
                            else
                                     v:SetAttribute("Enabled", false)
                                if not v.Sound.Playing then
                                          v.Sound.Playing = true
                                       end
                                       v.PrismaticConstraint.TargetPosition = 0.2
                                        v.Material = Enum.Material.Glass
                                solved = false
                            end
                             end
                    end
                      end

                if solved and RemoteFolder then
                           local breakerRemote = RemoteFolder:FindFirstChild("BreakerMinigame")
                    if breakerRemote then
                        breakerRemote:FireServer("Solved")
                            end
                        end
            end
        end
    end
})




local function findItem(name)
	local char, backpack = LocalPlayer.Character, LocalPlayer.Backpack
	return char:FindFirstChild(name) or backpack:FindFirstChild(name)
end

local function getLibraryCode()
	local paper = findItem("LibraryHintPaper")
	if not paper then
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= LocalPlayer then
				paper = (p.Character and p.Character:FindFirstChild("LibraryHintPaper")) or (p.Backpack and p.Backpack:FindFirstChild("LibraryHintPaper"))
				if paper then break end
			end
		end
	end
	if not paper then return nil, "No code paper" end

	local ui = paper:FindFirstChild("UI")
	if not ui then return nil, "Paper missing UI" end

	local code, found = "", 0
	for _, icon in ipairs(ui:GetChildren()) do
		if tonumber(icon.Name) then
			found = found + 1
			for _, hint in ipairs(LocalPlayer.PlayerGui.PermUI.Hints:GetChildren()) do
				if hint.Name == "Icon" and hint.ImageRectOffset == icon.ImageRectOffset then
					code = code .. hint.TextLabel.Text
				end
			end
		end
	end

	if #code == 5 then
		return code, "ok"
	elseif found > 0 then
		return nil, "Only found " .. found .. "/5"
	else
		return nil, "No symbols found"
	end
end


AutomationGroup:AddButton("solvecode", {
	Text = "Solve Library Code",
	Tooltip = "Finds and submits the padlock code",
	Func = function()
		local code, status = getLibraryCode()
		if not code then
			Library:Notify(status or "Failed", 3)
			return
		end

		Library:Notify("Library Code: " .. code, 3)
		print("[Solver] Code:", code)

		local padlock = workspace:FindFirstChild("Padlock", true)
		if not padlock then return end

		local part = padlock.PrimaryPart or padlock:FindFirstChildWhichIsA("BasePart")
		if not part then return end

		local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		if (hrp.Position - part.Position).Magnitude <= 20 and tonumber(code) then
			local remote = game.ReplicatedStorage:WaitForChild("RemotesFolder"):FindFirstChild("PL")
			if remote then
				remote:FireServer(tonumber(code))
			end
		end
	end
})






















local promptDefaults = {}
local connections = {}

local function setPromptRange(prompt, mult)
	if not promptDefaults[prompt] then
		promptDefaults[prompt] = prompt.MaxActivationDistance
	end
	prompt.MaxActivationDistance = promptDefaults[prompt] * mult
end

local function applyPromptRange(mult)
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("ProximityPrompt") then
			setPromptRange(obj, mult)
		end
	end
	for _, p in ipairs(Players:GetPlayers()) do
		if p:FindFirstChild("PlayerGui") then
			for _, obj in ipairs(p.PlayerGui:GetDescendants()) do
				if obj:IsA("ProximityPrompt") then
					setPromptRange(obj, mult)
				end
			end
		end
	end
end

local function watchForNewPrompts(mult)
	for _, c in pairs(connections) do c:Disconnect() end
	table.clear(connections)

	table.insert(connections, workspace.DescendantAdded:Connect(function(obj)
		if obj:IsA("ProximityPrompt") then
			task.wait()
			setPromptRange(obj, mult)
		end
	end))

	for _, p in ipairs(Players:GetPlayers()) do
		if p:FindFirstChild("PlayerGui") then
			table.insert(connections, p.PlayerGui.DescendantAdded:Connect(function(obj)
				if obj:IsA("ProximityPrompt") then
					task.wait()
					setPromptRange(obj, mult)
				end
			end))
		end
	end
end






AutomationGroup:AddButton({
    Text = "Beat Door 200",
    Visible = (fireproximityprompt ~= nil),
    Func = function()
        local player = game.Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local root = char:WaitForChild("HumanoidRootPart")
        local speed = 65

        local function flyTo(target)
            while (root.Position - target.Position).Magnitude > 6 do
                local dir = (target.Position - root.Position).Unit
                root.CFrame = root.CFrame + dir * (speed * task.wait())
            end
            char:PivotTo(target.CFrame)
        end

        local startPos = root.CFrame
        local room = workspace.CurrentRooms:FindFirstChild(tostring(game.ReplicatedStorage.GameData.LatestRoom.Value))
        if not room then
            Library:Notify("bud is NOT in room 200", 3)
            return
        end

        local damHandler = room:FindFirstChild("_DamHandler")
        if not damHandler then
            Library:Notify("bud is NOT in room 200", 3)
            return
        end

        if damHandler:FindFirstChild("PlayerBarriers1") and damHandler:FindFirstChild("Flood1") then
            for _, pump in pairs(damHandler.Flood1.Pumps:GetChildren()) do
                flyTo(pump.Wheel)
                task.wait(0.25)
                fireproximityprompt(pump.Wheel.ValvePrompt)
                task.wait(0.25)
            end
            task.wait(8)
        end

        if damHandler:FindFirstChild("PlayerBarriers2") and damHandler:FindFirstChild("Flood2") then
            for _, pump in pairs(damHandler.Flood2.Pumps:GetChildren()) do
                flyTo(pump.Wheel)
                task.wait(0.25)
                fireproximityprompt(pump.Wheel.ValvePrompt)
                task.wait(0.25)
            end
            task.wait(8)
        end

        if damHandler:FindFirstChild("PlayerBarriers3") and damHandler:FindFirstChild("Flood3") then
            for _, pump in pairs(damHandler.Flood3.Pumps:GetChildren()) do
                flyTo(pump.Wheel)
                task.wait(0.25)
                fireproximityprompt(pump.Wheel.ValvePrompt)
                task.wait(0.25)
            end
            task.wait(10)
        end

        local generator = room:FindFirstChild("MinesGenerator", true)
        if generator then
            flyTo(generator.PrimaryPart)
            task.wait(0.25)
            fireproximityprompt(generator.Lever.LeverPrompt)
            task.wait(0.25)
        end

        char:PivotTo(startPos)
    end
})









local ESPSettings = Tabs.Visuals:AddLeftGroupbox("ESP Settings")




local ESP_Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/bocaj111004/ESPLibrary/refs/heads/main/Library.lua"))()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

_G.FadeTime = _G.FadeTime or 0.5

ESP_Library:SetFadeTime(_G.FadeTime)
ESP_Library:SetShowDistance(true)
ESP_Library:SetFillTransparency(0.75)
ESP_Library:SetOutlineTransparency(0)
ESP_Library:SetTextTransparency(0)
ESP_Library:SetTextOutlineTransparency(0)
ESP_Library:SetTextSize(17)


local VisualsGroup = Tabs.Visuals:AddLeftGroupbox("Object ESP")



ESPSettings:AddCheckbox("ESPRainbow", {
    Text = "Rainbow Mode (global)",
    Default = false,
    Tooltip = "When enabled, all ESPs will smoothly cycle colors.",
    Callback = function(Value)
        ESP_Library:SetRainbow(Value)
        _G.ESPRainbowEnabled = Value
    end
})

ESPSettings:AddCheckbox("EnableTracers", {
    Text = "Enable Tracers",
    Default = false,
    Tooltip = "Enables tracers for all ESPs",
    Callback = function(Value)
        ESP_Library:SetTracers(Value)
        _G.EnableTracers = Value
    end
})

ESPSettings:AddCheckbox("EnableArrows", {
    Text = "Enable Arrows",
    Default = false,
    Tooltip = "Enables arrows for all ESPs",
    Callback = function(Value)
        ESP_Library:SetArrows(Value)
        _G.EnableArrows = Value
    end
})

ESPSettings:AddDropdown("TracerOrigin", {
    Text = "Tracer Origin",
    Default = "Bottom",
    Multi = false,
    Values = {"Bottom", "Center", "Top", "Mouse"},
    Tooltip = "Select origin point for tracers",
    Callback = function(Value)
        ESP_Library:SetTracerOrigin(Value)
    end
})

ESPSettings:AddSlider("TracerSize", {
    Text = "Tracer Size",
    Default = 1,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Tooltip = "Adjusts thickness of tracer lines",
    Callback = function(Value)
        ESP_Library:SetTracerSize(Value)
    end
})

ESPSettings:AddSlider("ArrowRadius", {
    Text = "Arrow Radius",
    Default = 200,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Compact = true,
    Tooltip = "Adjusts distance from center for arrows",
    Callback = function(Value)
        ESP_Library:SetArrowRadius(Value)
    end
})

ESPSettings:AddSlider("ESPDistance", {
    Text = "ESP Distance",
    Default = 100,
    Min = 50,
    Max = 1000,
    Rounding = 0,
    Compact = true,
    Tooltip = "Maximum distance (studs) to display ESP for all object types.",
    Callback = function(Value)
        _G.ESPDistance = Value
    end
})

_G.ESPDistance = _G.ESPDistance or 200
_G.ESPRainbowEnabled = _G.ESPRainbowEnabled or false

local function getRoomsContainer()
    return Workspace:FindFirstChild("CurrentRooms") or Workspace:WaitForChild("CurrentRooms")
end

local function playerRoot()
    local char = LocalPlayer.Character
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
end

local function distanceBetweenRootAndPart(part)
    local root = playerRoot()
    if not root or not part or not part:IsA("BasePart") then return math.huge end
    return (root.Position - part.Position).Magnitude
end

local function getESPColor(baseColor)
    return baseColor
end

local function addESPWithDynamicColor(object, text, basePart, baseColor)
    local color = getESPColor(baseColor)
    ESP_Library:AddESP({
        Object = object,
        Text = text,
        Color = color,
        BasePart = basePart
    })
end



VisualsGroup:AddCheckbox("EntityESP", {
    Text = "Entity ESP",
    Default = false,
    Tooltip = "Shows Rush, Ambush, Blitz, Figure, Seek, etc.",
    Callback = function(Value)
        local AllowedEntities = {
            ["RushMoving"] = {targetPart = "RushNew", name = "Rush"},
            ["AmbushMoving"] = {targetPart = "RushNew", name = "Ambush"}, 
            ["BackdoorRush"] = {targetPart = "Main", name = "Blitz"},
            ["FigureRig"] = {name = "Figure"},
            ["Snare"] = {targetPart = "Main", name = "Snare"},
            ["GiggleCeiling"] = {targetPart = "Main", name = "Giggle"},
            ["EyestalkMoving"] = {targetPart = "Main", name = "Eyestalk"},
            ["Mandrake"] = {targetPart = "Main", name = "Mandrake"},
            ["Groundskeeper"] = {targetPart = "Main", name = "Groundskeeper"},
            ["A60"] = {targetPart = "Main", name = "A60"},
            ["A120"] = {targetPart = "Main", name = "A120"},        
            ["GrumbleRig"] = {targetPart = "Root", name = "Grumble"},
            ["SeekMovingNewClone"] = {targetPart = "Hitbox", name = "Seek"}
        }

        _G.RushAmbushBlitzESP_Elements = _G.RushAmbushBlitzESP_Elements or {}
        _G.RushAmbushBlitzESP_Trans = _G.RushAmbushBlitzESP_Trans or {}

        local lastUpdate = 0
        local UPDATE_INTERVAL = 0.033

        local function getTargetPart(model)
            local config = AllowedEntities[model.Name]
            if not config then return nil end
            if config.targetPart then
                local part = model:FindFirstChild(config.targetPart)
                if part and part:IsA("BasePart") then return part end
            end
            return model.PrimaryPart or model
        end

        local function handleTransparency(target, enable)
            if not target or not target:IsA("BasePart") then return end
            if enable then
                if not _G.RushAmbushBlitzESP_Trans[target] then
                    _G.RushAmbushBlitzESP_Trans[target] = target.Transparency
                end
                target.Transparency = 0
            elseif _G.RushAmbushBlitzESP_Trans[target] then
                target.Transparency = _G.RushAmbushBlitzESP_Trans[target]
                _G.RushAmbushBlitzESP_Trans[target] = nil
            end
        end

        local function addESP(model)
            local target = getTargetPart(model)
            if not target then return end
            local config = AllowedEntities[model.Name]
            if not config then return end
            local dist = distanceBetweenRootAndPart(target)
            if dist > _G.ESPDistance then return end
            local rec = _G.RushAmbushBlitzESP_Elements[model]
            if rec and rec.added then return end
            local basePart = target:IsA("BasePart") and target or target.PrimaryPart
            if not basePart then return end
            handleTransparency(target, true)
            local color = Options.RushAmbushBlitzESP_Color.Value
            addESPWithDynamicColor(target, config.name, basePart, color)
            _G.RushAmbushBlitzESP_Elements[model] = {model = model, target = target, added = true}
        end

        local function removeESPRecord(rec)
            if not rec or not rec.added or not rec.target then return end
            ESP_Library:RemoveESP(rec.target)
            if rec.target:IsA("BasePart") then handleTransparency(rec.target, false) end
        end

        local function cleanup()
            if _G.RushAmbushBlitzESP_Add then _G.RushAmbushBlitzESP_Add:Disconnect() _G.RushAmbushBlitzESP_Add = nil end
            if _G.RushAmbushBlitzESP_Update then _G.RushAmbushBlitzESP_Update:Disconnect() _G.RushAmbushBlitzESP_Update = nil end
            for _, rec in pairs(_G.RushAmbushBlitzESP_Elements or {}) do removeESPRecord(rec) end
            _G.RushAmbushBlitzESP_Elements = {}
            _G.RushAmbushBlitzESP_Trans = {}
        end

        if Value then
            cleanup()
            local ws = workspace
            for _, v in pairs(ws:GetDescendants()) do
                if v:IsA("Model") and AllowedEntities[v.Name] then addESP(v) end
            end
            _G.RushAmbushBlitzESP_Add = ws.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and AllowedEntities[v.Name] then
                    task.wait(0.05)
                    addESP(v)
                end
            end)
            _G.RushAmbushBlitzESP_Update = RunService.Heartbeat:Connect(function()
                local now = tick()
                if now - lastUpdate < UPDATE_INTERVAL then return end
                lastUpdate = now
                
                local root = playerRoot()
                if not root then return end
                local color = Options.RushAmbushBlitzESP_Color.Value
                local espColor = getESPColor(color)
                local toRemove = {}
                for model, rec in pairs(_G.RushAmbushBlitzESP_Elements) do
                    if not model or not rec then 
                        table.insert(toRemove, model)
                    else
                        local entityConfig = AllowedEntities[model.Name]
                        if not entityConfig then 
                            table.insert(toRemove, model)
                        else
                            local target = model.Name == "FigureRig" and model or getTargetPart(model)
                            if not target or not target.Parent then
                                removeESPRecord(rec)
                                table.insert(toRemove, model)
                            else
                                rec.target = target
                                local dist = distanceBetweenRootAndPart(target)
                                local basePart = target:IsA("BasePart") and target or target.PrimaryPart
                                if not basePart then
                                    removeESPRecord(rec)
                                    table.insert(toRemove, model)
                                else
                                    local entityName = entityConfig.name
                                    if dist <= _G.ESPDistance then
                                        if not rec.added then
                                            addESPWithDynamicColor(target, entityName, basePart, color)
                                            rec.added = true
                                            handleTransparency(target, true)
                                        else
                                            ESP_Library:UpdateObjectColor(target, espColor)
                                            ESP_Library:UpdateObjectText(target, entityName)
                                        end
                                    elseif rec.added then
                                        removeESPRecord(rec)
                                        rec.added = false
                                    end
                                end
                            end
                        end
                    end
                end
                for _, m in ipairs(toRemove) do _G.RushAmbushBlitzESP_Elements[m] = nil end
            end)
        else
            cleanup()
        end
    end
}):AddColorPicker("RushAmbushBlitzESP_Color", {
    Default = Color3.fromRGB(255, 255, 255),
    Title = "Rush/Ambush/Blitz Color",
    Callback = function(Value)
        local espColor = getESPColor(Value)
        for _, rec in pairs(_G.RushAmbushBlitzESP_Elements or {}) do
            if rec and rec.added and rec.target then ESP_Library:UpdateObjectColor(rec.target, espColor) end
        end
    end
})

VisualsGroup:AddCheckbox("PlayerESP", {
    Text = "Player ESP",
    Default = false,
    Tooltip = "Highlights players with name and distance",
    Callback = function(Value)
        _G.PlayerESP_Elements = _G.PlayerESP_Elements or {}
        _G.PlayerESP_Color = _G.PlayerESP_Color or Color3.fromRGB(0, 255, 0)
        
        local function createRecordForCharacter(player, character)
            if not player or player == LocalPlayer then return end
            if not character or not character:IsA("Model") then return end
            local root = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
            if not root then return end
            _G.PlayerESP_Elements[player] = _G.PlayerESP_Elements[player] or {player = player, root = root, object = character, added = false}
            local rec = _G.PlayerESP_Elements[player]
            local dist = distanceBetweenRootAndPart(root)
            if dist <= _G.ESPDistance and not rec.added then
                addESPWithDynamicColor(rec.object, player.DisplayName or player.Name, rec.root, _G.PlayerESP_Color)
                rec.added = true
            elseif dist > _G.ESPDistance and rec.added then
                ESP_Library:RemoveESP(rec.object)
                rec.added = false
            end
        end
        
        local function removeForPlayer(player)
            local rec = _G.PlayerESP_Elements[player]
            if rec and rec.added then
                ESP_Library:RemoveESP(rec.object)
            end
            _G.PlayerESP_Elements[player] = nil
        end
        
        if Value then
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    if player.Character then
                        createRecordForCharacter(player, player.Character)
                    end
                    player.CharacterAdded:Connect(function(char)
                        task.wait(0.5)
                        createRecordForCharacter(player, char)
                    end)
                    player.CharacterRemoving:Connect(function()
                        removeForPlayer(player)
                    end)
                end
            end
            
            _G.PlayerESP_PlayerAdded = Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function(char)
                    task.wait(0.5)
                    createRecordForCharacter(player, char)
                end)
                player.CharacterRemoving:Connect(function()
                    removeForPlayer(player)
                end)
            end)
            
            _G.PlayerESP_PlayerRemoving = Players.PlayerRemoving:Connect(function(player)
                removeForPlayer(player)
            end)
            
            _G.PlayerESP_Update = RunService.Heartbeat:Connect(function()
                local lpRoot = playerRoot()
                if not lpRoot then return end
                for player, rec in pairs(_G.PlayerESP_Elements) do
                    if not player or not player.Parent then
                        removeForPlayer(player)
                    else
                        local char = player.Character
                        local targetRoot = rec and rec.root
                        if char and targetRoot and targetRoot.Parent then
                            local dist = (lpRoot.Position - targetRoot.Position).Magnitude
                            if dist <= _G.ESPDistance then
                                if not rec.added then
                                    addESPWithDynamicColor(rec.object, player.DisplayName or player.Name, targetRoot, _G.PlayerESP_Color)
                                    rec.added = true
                                else
                                    ESP_Library:UpdateObjectText(rec.object, player.DisplayName or player.Name)
                                    ESP_Library:UpdateObjectColor(rec.object, getESPColor(_G.PlayerESP_Color))
                                end
                            else
                                if rec.added then
                                    ESP_Library:RemoveESP(rec.object)
                                    rec.added = false
                                end
                            end
                        else
                            removeForPlayer(player)
                        end
                    end
                end
            end)
        else
            if _G.PlayerESP_PlayerAdded then _G.PlayerESP_PlayerAdded:Disconnect() end
            if _G.PlayerESP_PlayerRemoving then _G.PlayerESP_PlayerRemoving:Disconnect() end
            if _G.PlayerESP_Update then _G.PlayerESP_Update:Disconnect() end
            _G.PlayerESP_PlayerAdded, _G.PlayerESP_PlayerRemoving, _G.PlayerESP_Update = nil, nil, nil
            
            for _, rec in pairs(_G.PlayerESP_Elements or {}) do
                if rec and rec.added then
                    ESP_Library:RemoveESP(rec.object)
                end
            end
            _G.PlayerESP_Elements = {}
        end
    end
}):AddColorPicker("PlayerESP_Color", {
    Default = Color3.fromRGB(0, 255, 0),
    Title = "Player Color",
    Callback = function(Value)
        _G.PlayerESP_Color = Value
        for _, rec in pairs(_G.PlayerESP_Elements or {}) do
            if rec and rec.added then
                ESP_Library:UpdateObjectColor(rec.object, getESPColor(Value))
            end
        end
    end
})

VisualsGroup:AddCheckbox("DoorESP", {
    Text = "Door ESP",
    Default = false,
    Tooltip = "Shows doors through walls",
    Callback = function(Value)
        local Rooms = getRoomsContainer()
        _G.DoorESP_Elements = _G.DoorESP_Elements or {}
        _G.DoorESP_Color = _G.DoorESP_Color or Color3.fromRGB(0, 255, 255)
        
        local function addRecord(model)
            local mesh = model:FindFirstChild("Door")
            if mesh and mesh:IsA("BasePart") and not _G.DoorESP_Elements[mesh] then
                _G.DoorESP_Elements[mesh] = {mesh = mesh, added = false}
            end
        end
        
        local function removeRecord(mesh)
            local rec = _G.DoorESP_Elements[mesh]
            if rec and rec.added then
                ESP_Library:RemoveESP(mesh)
            end
            _G.DoorESP_Elements[mesh] = nil
        end
        
        if Value then
            for _, v in pairs(Rooms:GetDescendants()) do
                if v:IsA("Model") and v.Name == "Door" then
                    addRecord(v)
                end
            end
            
            _G.DoorESP_Add = Rooms.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and v.Name == "Door" then
                    addRecord(v)
                end
            end)
            
            _G.DoorESP_Remove = Rooms.DescendantRemoving:Connect(function(v)
                if v:IsA("BasePart") and v.Name == "Door" then
                    removeRecord(v)
                end
            end)
            
            _G.DoorESP_Update = RunService.Heartbeat:Connect(function()
                local root = playerRoot()
                if not root then return end
                for mesh, rec in pairs(_G.DoorESP_Elements) do
                    local currentMesh = rec.mesh
                    if not currentMesh or not currentMesh.Parent then
                        removeRecord(mesh)
                    else
                        local dist = distanceBetweenRootAndPart(currentMesh)
                        if dist <= _G.ESPDistance then
                            if not rec.added then
                                addESPWithDynamicColor(currentMesh, "Door", currentMesh, _G.DoorESP_Color)
                                rec.added = true
                            else
                                ESP_Library:UpdateObjectColor(currentMesh, getESPColor(_G.DoorESP_Color))
                            end
                        else
                            if rec.added then
                                ESP_Library:RemoveESP(currentMesh)
                                rec.added = false
                            end
                        end
                    end
                end
            end)
        else
            if _G.DoorESP_Add then _G.DoorESP_Add:Disconnect() end
            if _G.DoorESP_Remove then _G.DoorESP_Remove:Disconnect() end
            if _G.DoorESP_Update then _G.DoorESP_Update:Disconnect() end
            _G.DoorESP_Add, _G.DoorESP_Remove, _G.DoorESP_Update = nil, nil, nil
            
            for _, rec in pairs(_G.DoorESP_Elements or {}) do
                if rec and rec.added and rec.mesh then
                    ESP_Library:RemoveESP(rec.mesh)
                end
            end
            _G.DoorESP_Elements = {}
        end
    end
}):AddColorPicker("DoorESP_Color", {
    Default = Color3.fromRGB(0, 255, 255),
    Title = "Door Color",
    Callback = function(Value)
        _G.DoorESP_Color = Value
        for _, rec in pairs(_G.DoorESP_Elements or {}) do
            if rec and rec.added and rec.mesh then
                ESP_Library:UpdateObjectColor(rec.mesh, getESPColor(Value))
            end
        end
    end
})
VisualsGroup:AddCheckbox("ObjectiveESP", {
    Text = "Objective ESP",
    Default = false,
    Tooltip = "Highlights all objective items",
    Callback = function(Value)
        local Rooms = getRoomsContainer()
        local AllowedModels = {
            ["KeyObtain"] = "Key", ["FuseObtain"] = "Fuse", ["LiveBreakerPolePickup"] = "Breaker",
            ["MinesGenerator"] = "Generator", ["LeverForGate"] = "Lever", ["TrickOrTreatHouse"] = "House", ["MinesAnchor"] = "Anchor",
            ["TimerLever"] = "Lever", ["LiveHintBook"] = "Book"
        }
        _G.ObjectiveESP_Elements = _G.ObjectiveESP_Elements or {}
        _G.ObjectiveESP_Color = _G.ObjectiveESP_Color or Color3.fromRGB(255, 255, 0)
        
        local function addRecord(model)
            if not AllowedModels[model.Name] or not model.PrimaryPart or _G.ObjectiveESP_Elements[model] then return end
            _G.ObjectiveESP_Elements[model] = {model = model, added = false}
            local dist = distanceBetweenRootAndPart(model.PrimaryPart)
            if dist <= _G.ESPDistance then
                addESPWithDynamicColor(model, AllowedModels[model.Name], model.PrimaryPart, _G.ObjectiveESP_Color)
                _G.ObjectiveESP_Elements[model].added = true
            end
        end
        
        local function removeRecord(model)
            local rec = _G.ObjectiveESP_Elements[model]
            if rec and rec.added then
                ESP_Library:RemoveESP(model)
            end
            _G.ObjectiveESP_Elements[model] = nil
        end
        
        if Value then
            for _, rec in pairs(_G.ObjectiveESP_Elements or {}) do
                if rec and rec.added then
                    ESP_Library:RemoveESP(rec.model)
                end
            end
            _G.ObjectiveESP_Elements = {}
            
            for _, v in pairs(Rooms:GetDescendants()) do
                if v:IsA("Model") and AllowedModels[v.Name] and v.PrimaryPart then
                    addRecord(v)
                end
            end
            
            _G.ObjectiveESP_Add = Rooms.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and AllowedModels[v.Name] and v.PrimaryPart then
                    addRecord(v)
                end
            end)
            
            _G.ObjectiveESP_Remove = Rooms.DescendantRemoving:Connect(function(v)
                if v:IsA("Model") and AllowedModels[v.Name] then
                    removeRecord(v)
                end
            end)
            
            _G.ObjectiveESP_Update = RunService.Heartbeat:Connect(function()
                local root = playerRoot()
                if not root then return end
                for model, rec in pairs(_G.ObjectiveESP_Elements) do
                    if model and model.Parent and model.PrimaryPart then
                        local dist = distanceBetweenRootAndPart(model.PrimaryPart)
                        if dist <= _G.ESPDistance then
                            if not rec.added then
                                addESPWithDynamicColor(model, AllowedModels[model.Name], model.PrimaryPart, _G.ObjectiveESP_Color)
                                rec.added = true
                            else
                                ESP_Library:UpdateObjectColor(model, getESPColor(_G.ObjectiveESP_Color))
                            end
                        else
                            if rec.added then
                                ESP_Library:RemoveESP(model)
                                rec.added = false
                            end
                        end
                    else
                        removeRecord(model)
                    end
                end
            end)
        else
            if _G.ObjectiveESP_Add then _G.ObjectiveESP_Add:Disconnect() _G.ObjectiveESP_Add = nil end
            if _G.ObjectiveESP_Remove then _G.ObjectiveESP_Remove:Disconnect() _G.ObjectiveESP_Remove = nil end
            if _G.ObjectiveESP_Update then _G.ObjectiveESP_Update:Disconnect() _G.ObjectiveESP_Update = nil end
            
            for _, rec in pairs(_G.ObjectiveESP_Elements or {}) do
                if rec and rec.added then
                    ESP_Library:RemoveESP(rec.model)
                end
            end
            _G.ObjectiveESP_Elements = {}
        end
    end
}):AddColorPicker("ObjectiveESP_Color", {
    Default = Color3.fromRGB(255, 255, 0),
    Title = "Objective Item Color",
    Callback = function(Value)
        _G.ObjectiveESP_Color = Value
        for _, rec in pairs(_G.ObjectiveESP_Elements or {}) do
            if rec and rec.added then
                ESP_Library:UpdateObjectColor(rec.model, getESPColor(Value))
            end
        end
    end
})


VisualsGroup:AddCheckbox("MoneyESP", {
    Text = "Money ESP",
    Default = false,
    Tooltip = "Highlights all worthy items",
    Callback = function(Value)
        local AllowedModels = {
            ["CoinPile"] = "Coin", ["ChestBox"] = "Chestbox", ["ChestBoxLocked"] = "Chestbox", 
            ["StardustPickup"] = "Stardust", ["GoldPile"] = "Gold"
        }
        _G.MoneyESP_Elements = _G.MoneyESP_Elements or {}
        _G.MoneyESP_Color = _G.MoneyESP_Color or Color3.fromRGB(255, 255, 0)

        local function addRecord(model)
            if not AllowedModels[model.Name] then return end
            local primary = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
            if not primary or _G.MoneyESP_Elements[model] then return end
            _G.MoneyESP_Elements[model] = {model=model, primary=primary, added=false}
            if distanceBetweenRootAndPart(primary) <= _G.ESPDistance then
                addESPWithDynamicColor(model, AllowedModels[model.Name], primary, _G.MoneyESP_Color)
                _G.MoneyESP_Elements[model].added = true
            end
        end

        local function removeRecord(model)
            local rec = _G.MoneyESP_Elements[model]
            if rec and rec.added then ESP_Library:RemoveESP(model) end
            _G.MoneyESP_Elements[model] = nil
        end

        if Value then
            for _, rec in pairs(_G.MoneyESP_Elements or {}) do
                if rec and rec.added then ESP_Library:RemoveESP(rec.model) end
            end
            _G.MoneyESP_Elements = {}
            
            for _, v in pairs(workspace:GetDescendants()) do
                if v:IsA("Model") and AllowedModels[v.Name] then
                    addRecord(v)
                end
            end

            _G.MoneyESP_Add = workspace.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and AllowedModels[v.Name] then addRecord(v) end
            end)
            
            _G.MoneyESP_Remove = workspace.DescendantRemoving:Connect(function(v)
                if v:IsA("Model") and AllowedModels[v.Name] then removeRecord(v) end
            end)
            
            _G.MoneyESP_Update = RunService.Heartbeat:Connect(function()
                local root = playerRoot()
                if not root then return end
                for model, rec in pairs(_G.MoneyESP_Elements) do
                    if model and model.Parent then
                        local primary = rec.primary or model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                        if not primary then removeRecord(model) return end
                        local dist = distanceBetweenRootAndPart(primary)
                        if dist <= _G.ESPDistance then
                            if not rec.added then
                                addESPWithDynamicColor(model, AllowedModels[model.Name], primary, _G.MoneyESP_Color)
                                rec.added = true
                            else
                                ESP_Library:UpdateObjectColor(model, getESPColor(_G.MoneyESP_Color))
                            end
                        else
                            if rec.added then
                                ESP_Library:RemoveESP(model)
                                rec.added = false
                            end
                        end
                    else
                        removeRecord(model)
                    end
                end
            end)
        else
            if _G.MoneyESP_Add then _G.MoneyESP_Add:Disconnect() _G.MoneyESP_Add = nil end
            if _G.MoneyESP_Remove then _G.MoneyESP_Remove:Disconnect() _G.MoneyESP_Remove = nil end
            if _G.MoneyESP_Update then _G.MoneyESP_Update:Disconnect() _G.MoneyESP_Update = nil end
            for _, rec in pairs(_G.MoneyESP_Elements or {}) do
                if rec and rec.added then ESP_Library:RemoveESP(rec.model) end
            end
            _G.MoneyESP_Elements = {}
        end
    end
}):AddColorPicker("MoneyESP_Color", {
    Default = Color3.fromRGB(255, 255, 0),
    Title = "Money Color",
    Callback = function(Value)
        _G.MoneyESP_Color = Value
        for _, rec in pairs(_G.MoneyESP_Elements or {}) do
            if rec and rec.added then ESP_Library:UpdateObjectColor(rec.model, getESPColor(Value)) end
        end
    end
})


VisualsGroup:AddCheckbox("ItemESP", {
    Text = "Item ESP",
    Default = false,
    Tooltip = "Highlights all interactable items",
    Callback = function(Value)
        local Rooms = getRoomsContainer()
        local Drops = workspace:WaitForChild("Drops")
        local AllowedModels = {
            ["AlarmClock"]=true, ["GlitchCube"]=true, ["Aloe"]=true, ["BandagePack"]=true,
            ["Battery"]=true, ["OuterPart"]=true, ["BatteryPack"]=true, ["Candle"]=true, ["Candy"]=true, ["CandyBag"]=true, ["Compass"]=true, ["Crucifix"]=true,
            ["ElectricalRoomKey"]=true, ["Flashlight"]=true, ["Glowstick"]=true,
            ["HolyHandGrenade"]=true, ["Lantern"]=true, ["LaserPointer"]=true,
            ["Lighter"]=true, ["Lockpick"]=true, ["LotusFlower"]=true,
            ["LotusPetalPickup"]=true, ["Multitool"]=true, ["NVCS3000"]=true,
            ["OutdoorsKey"]=true, ["Shears"]=true, ["SkeletonKey"]=true,
            ["Smoothie"]=true, ["SolutionPaper"]=true, ["Spotlight"]=true,
            ["StarlightVial"]=true, ["StarlightJug"]=true, ["StarlightBottle"]=true,
            ["Vitamins"]=true
        }
        _G.ItemESP_Elements = _G.ItemESP_Elements or {}
        _G.ItemESP_Color = _G.ItemESP_Color or Color3.fromRGB(255, 255, 0)

        local function addRecord(model)
            if not AllowedModels[model.Name] or not model.PrimaryPart or _G.ItemESP_Elements[model] then return end
            _G.ItemESP_Elements[model] = {model=model, added=false}
            local dist = distanceBetweenRootAndPart(model.PrimaryPart)
            if dist <= _G.ESPDistance then
                addESPWithDynamicColor(model, model.Name, model.PrimaryPart, _G.ItemESP_Color)
                _G.ItemESP_Elements[model].added = true
            end
        end

        local function removeRecord(model)
            local rec = _G.ItemESP_Elements[model]
            if rec and rec.added then
                ESP_Library:RemoveESP(model)
            end
            _G.ItemESP_Elements[model] = nil
        end

        if Value then
            for _, rec in pairs(_G.ItemESP_Elements or {}) do
                if rec and rec.added then
                    ESP_Library:RemoveESP(rec.model)
                end
            end
            _G.ItemESP_Elements = {}
            
            for _, v in pairs(Rooms:GetDescendants()) do
                if v:IsA("Model") and AllowedModels[v.Name] and v.PrimaryPart then
                    addRecord(v)
                end
            end
            for _, v in pairs(Drops:GetDescendants()) do
                if v:IsA("Model") and AllowedModels[v.Name] and v.PrimaryPart then
                    addRecord(v)
                end
            end

            _G.ItemESP_Add = Rooms.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and AllowedModels[v.Name] and v.PrimaryPart then
                    addRecord(v)
                end
            end)
            
            _G.ItemESP_DropsAdd = Drops.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and AllowedModels[v.Name] and v.PrimaryPart then
                    addRecord(v)
                end
            end)
            
            _G.ItemESP_Update = RunService.Heartbeat:Connect(function()
                local root = playerRoot()
                if not root then return end
                for model, rec in pairs(_G.ItemESP_Elements) do
                    if model and model.Parent and model.PrimaryPart then
                        local dist = distanceBetweenRootAndPart(model.PrimaryPart)
                        if dist <= _G.ESPDistance then
                            if not rec.added then
                                addESPWithDynamicColor(model, model.Name, model.PrimaryPart, _G.ItemESP_Color)
                                rec.added = true
                            else
                                ESP_Library:UpdateObjectColor(model, getESPColor(_G.ItemESP_Color))
                            end
                        else
                            if rec.added then
                                ESP_Library:RemoveESP(model)
                                rec.added = false
                            end
                        end
                    else
                        removeRecord(model)
                    end
                end
            end)
        else
            if _G.ItemESP_Add then _G.ItemESP_Add:Disconnect() _G.ItemESP_Add = nil end
            if _G.ItemESP_DropsAdd then _G.ItemESP_DropsAdd:Disconnect() _G.ItemESP_DropsAdd = nil end
            if _G.ItemESP_Update then _G.ItemESP_Update:Disconnect() _G.ItemESP_Update = nil end
            for _, rec in pairs(_G.ItemESP_Elements or {}) do
                if rec and rec.added then
                    ESP_Library:RemoveESP(rec.model)
                end
            end
            _G.ItemESP_Elements = {}
        end
    end
}):AddColorPicker("ItemESP_Color", {
    Default = Color3.fromRGB(255, 255, 0),
    Title = "Item Color",
    Callback = function(Value)
        _G.ItemESP_Color = Value
        for _, rec in pairs(_G.ItemESP_Elements or {}) do
            if rec and rec.added then
                ESP_Library:UpdateObjectColor(rec.model, getESPColor(Value))
            end
        end
    end
})

VisualsGroup:AddCheckbox("ClosetESP", {
    Text = "Closet ESP",
    Default = false,
    Tooltip = "Shows closets through walls",
    Callback = function(Value)
        local Rooms = getRoomsContainer()
        local AllowedModels = {
            ["Wardrobe"] = true, ["Toolshed"] = true, ["Locker_Large"] = true, ["Backdoor_Wardrobe"] = true
        }
        _G.ClosetESP_Elements = _G.ClosetESP_Elements or {}
        _G.ClosetESP_Color = _G.ClosetESP_Color or Color3.fromRGB(0, 128, 0)
        
        local function addRecord(model)
            if not AllowedModels[model.Name] or not model.PrimaryPart or _G.ClosetESP_Elements[model] then return end
            _G.ClosetESP_Elements[model] = {model = model, added = false}
            local dist = distanceBetweenRootAndPart(model.PrimaryPart)
            if dist <= _G.ESPDistance then
                addESPWithDynamicColor(model, model.Name, model.PrimaryPart, _G.ClosetESP_Color)
                _G.ClosetESP_Elements[model].added = true
            end
        end
        
        local function removeRecord(model)
            local rec = _G.ClosetESP_Elements[model]
            if rec and rec.added then
                ESP_Library:RemoveESP(model)
            end
            _G.ClosetESP_Elements[model] = nil
        end
        
        if Value then
            for _, rec in pairs(_G.ClosetESP_Elements or {}) do
                if rec and rec.added then
                    ESP_Library:RemoveESP(rec.model)
                end
            end
            _G.ClosetESP_Elements = {}
            
            for _, v in pairs(Rooms:GetDescendants()) do
                if v:IsA("Model") and AllowedModels[v.Name] and v.PrimaryPart then
                    addRecord(v)
                end
            end
            
            _G.ClosetESP_Add = Rooms.DescendantAdded:Connect(function(v)
                if v:IsA("Model") and AllowedModels[v.Name] and v.PrimaryPart then
                    addRecord(v)
                end
            end)
            
            _G.ClosetESP_Update = RunService.Heartbeat:Connect(function()
                local root = playerRoot()
                if not root then return end
                for model, rec in pairs(_G.ClosetESP_Elements) do
                    if model and model.Parent and model.PrimaryPart then
                        local dist = distanceBetweenRootAndPart(model.PrimaryPart)
                        if dist <= _G.ESPDistance then
                            if not rec.added then
                                addESPWithDynamicColor(model, model.Name, model.PrimaryPart, _G.ClosetESP_Color)
                                rec.added = true
                            else
                                ESP_Library:UpdateObjectColor(model, getESPColor(_G.ClosetESP_Color))
                            end
                        else
                            if rec.added then
                                ESP_Library:RemoveESP(model)
                                rec.added = false
                            end
                        end
                    else
                        removeRecord(model)
                    end
                end
            end)
        else
            if _G.ClosetESP_Add then _G.ClosetESP_Add:Disconnect() _G.ClosetESP_Add = nil end
            if _G.ClosetESP_Update then _G.ClosetESP_Update:Disconnect() _G.ClosetESP_Update = nil end
            for _, rec in pairs(_G.ClosetESP_Elements or {}) do
                if rec and rec.added then
                    ESP_Library:RemoveESP(rec.model)
                end
            end
            _G.ClosetESP_Elements = {}
        end
    end
}):AddColorPicker("ClosetESP_Color", {
    Default = Color3.fromRGB(0, 128, 0),
    Title = "Closet Color",
    Callback = function(Value)
        _G.ClosetESP_Color = Value
        for _, rec in pairs(_G.ClosetESP_Elements or {}) do
            if rec and rec.added then
                ESP_Library:UpdateObjectColor(rec.model, getESPColor(Value))
            end
        end
    end
})









local LeftTabBox = Tabs.Visuals:AddRightTabbox("Left Tabbox")

local VisualsTab = LeftTabBox:AddTab("Visuals") 





local runService = game:GetService("RunService")

local RequiredMainGame = nil
pcall(function()
	RequiredMainGame = require(game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
	:WaitForChild("MainUI"):WaitForChild("Initiator"):WaitForChild("Main_Game"))
end)

VisualsTab:AddCheckbox("NoCameraShake", {
	Text = "No Camera Shake",
	Default = false,
    Visible = (checkcaller ~= nil and getloadedmodules ~= nil),
	Callback = function(Value)
		task.spawn(function()
			while Value and RequiredMainGame do
				task.wait()
				if typeof(RequiredMainGame.csgo) == "CFrame" then
					RequiredMainGame.csgo = CFrame.new()
				end
			end
		end)
	end
})

VisualsTab:AddCheckbox("NoHeadBob", {
	Text = "No Head Bob",
	Default = false,
    Visible = (checkcaller ~= nil and cloneref ~= nil),
	Callback = function(Value)
		if Value then
			if not _G.HeadBobDisabler then
				_G.HeadBobDisabler = runService.RenderStepped:Connect(function()
					if RequiredMainGame and RequiredMainGame.spring then
						if typeof(RequiredMainGame.spring.Target) == "Vector3" then
							RequiredMainGame.spring.Target = Vector3.zero
							RequiredMainGame.spring.Position = Vector3.zero
						end
					end
				end)
			end
		else
			if _G.HeadBobDisabler then
				_G.HeadBobDisabler:Disconnect()
				_G.HeadBobDisabler = nil
			end
		end
	end
})




VisualsTab:AddCheckbox("NoFog", {
	Text = "No Fog",
	Default = false,
	Disabled = false,
	Callback = function(Value)
		local lighting = game:GetService("Lighting")
		local cave = lighting:FindFirstChild("CaveAtmosphere")
		local atmosphere = lighting:FindFirstChild("Atmosphere")

		if Value then
			if cave and cave:IsA("Atmosphere") then
				cave.Density = 0
			end
			if atmosphere then
				atmosphere:Destroy()
			end
			lighting.FogStart = 1000000
			lighting.FogEnd = 1000000
		else
			if cave and cave:IsA("Atmosphere") then
				cave.Density = 0.15
			end
			if not lighting:FindFirstChild("Atmosphere") then
				local newAtmos = Instance.new("Atmosphere")
				newAtmos.Parent = lighting
			end
			lighting.FogStart = 150
			lighting.FogEnd = 150
		end
	end
})






local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local fullbrightEnabled = false
local ambienceColor = Color3.new(1, 1, 1)

VisualsTab:AddCheckbox("Ambience", {
    Text = "Fullbright",
    Default = false,
    Disabled = false,
    Tooltip = "Changes the map's color tint.",
    Callback = function(Value)
        fullbrightEnabled = Value
        Lighting.GlobalShadows = not Value
        Lighting.OutdoorAmbient = Value and ambienceColor or Color3.new(0, 0, 0)
    end
}):AddColorPicker("AmbienceColor", {
    Default = Color3.new(1, 1, 1),
    Title = "Color Tint",
    Callback = function(Value)
        ambienceColor = Value
        if fullbrightEnabled then
            Lighting.OutdoorAmbient = Value
        end
    end
})

coroutine.wrap(function()
    while true do
        if fullbrightEnabled then
            Lighting.GlobalShadows = false
            Lighting.OutdoorAmbient = ambienceColor
        end
        wait(1)
    end
end)()



VisualsTab:AddCheckbox("TransparentCloset", { 
    Text = "Transparent Closet", 
    Default = false, 
    Disabled = false,
    Callback = function(value)
        local rooms = workspace:WaitForChild("CurrentRooms")
        local player = game.Players.LocalPlayer
        local playerModel = workspace:WaitForChild(player.Name)

        if getgenv().TransparentClosetConn then
            getgenv().TransparentClosetConn:Disconnect()
            getgenv().TransparentClosetConn = nil
        end
        if getgenv().HidingAttrConn then
            getgenv().HidingAttrConn:Disconnect()
            getgenv().HidingAttrConn = nil
        end

        local function updateClosetsTransparency(isHiding)
            for _, v in ipairs(rooms:GetDescendants()) do
                if v:FindFirstChild("HidePrompt") then
                    for _, part in ipairs(v:GetChildren()) do
                        if part:IsA("BasePart") and not (part.Name == "PlayerCollision" or part.Name == "Collision") then
                            part.Transparency = (value and isHiding) and 0.6 or 0
                        end
                    end
                end
            end
        end

        if value then
            getgenv().HidingAttrConn = playerModel:GetAttributeChangedSignal("Hiding"):Connect(function()
                local isHiding = playerModel:GetAttribute("Hiding")
                updateClosetsTransparency(isHiding)
            end)

            getgenv().TransparentClosetConn = rooms.DescendantAdded:Connect(function(v)
                if v:FindFirstChild("HidePrompt") then
                    local isHiding = playerModel:GetAttribute("Hiding")
                    for _, part in ipairs(v:GetChildren()) do
                        if part:IsA("BasePart") and not (part.Name == "PlayerCollision" or part.Name == "Collision") then
                            part.Transparency = (isHiding and value) and 0.6 or 0
                        end
                    end
                end
            end)

            updateClosetsTransparency(playerModel:GetAttribute("Hiding"))
        else
            updateClosetsTransparency(false)
        end
    end
})




local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local FloorReplicated = ReplicatedStorage:FindFirstChild("FloorReplicated")
local timerValue = FloorReplicated and FloorReplicated:FindFirstChild("DigitalTimer")

VisualsTab:AddCheckbox("HasteTimer", { 
    Text = "Haste Timer", 
    Default = false, 
    Disabled = false,
    Callback = function(value) 
        if value then
            local playerGui = player:WaitForChild("PlayerGui")
            local screenGui = playerGui:FindFirstChild("HasteTimerGui")
            if not screenGui then
                screenGui = Instance.new("ScreenGui")
                screenGui.Name = "HasteTimerGui"
                screenGui.Parent = playerGui
            end

            local textButton = screenGui:FindFirstChild("TimerButton")
            if not textButton then
                textButton = Instance.new("TextButton")
                textButton.Name = "TimerButton"
                textButton.Size = UDim2.new(0.2, 0, 0.05, 0)
                textButton.Position = UDim2.new(0.4, 0, 0.9, 0) 
                textButton.Text = "00:00:00.000"
                textButton.TextSize = 14
                textButton.BackgroundTransparency = 0.5
                textButton.BackgroundColor3 = Color3.new(0, 0, 0)
                textButton.TextColor3 = Color3.new(1, 1, 1)
                textButton.Parent = screenGui
            end

            local function updateTimer()
                local total = timerValue.Value
                local hours = math.floor(total / 3600)
                local minutes = math.floor((total % 3600) / 60)
                local seconds = total % 60
                textButton.Text = string.format("%02d:%02d:%02d", hours, minutes, seconds)
            end

            updateTimer()

            if not textButton:FindFirstChild("Connection") then
                local conn = timerValue.Changed:Connect(updateTimer)
                conn.Name = "Connection"
                conn.Parent = textButton 
            end
        else
            local screenGui = player:FindFirstChild("PlayerGui"):FindFirstChild("HasteTimerGui")
            if screenGui then
                local button = screenGui:FindFirstChild("TimerButton")
                if button then
                    local conn = button:FindFirstChild("Connection")
                    if conn then
                        conn:Disconnect()
                    end
                end
                screenGui:Destroy()
            end
        end
    end
})



VisualsTab:AddDivider()




VisualsTab:AddCheckbox("Thirdperson", {
    Text = "Third Person View",
    Default = false,
    Disabled = false,
    Tooltip = "Shows your character from behind.",
    Callback = function(Value)
        if Value then
            AntiConnections["Thirdperson"] = RunService.RenderStepped:Connect(function()
                local Cam = workspace.CurrentCamera
                Cam.CFrame = Cam.CFrame * CFrame.new(Options.ThirdpersonOffset.Value, Options.ThirdpersonOffsetUp.Value, 3.5 * (Options.ThirdpersonDistance.Value / 7.5))
                
                local character = game.Players.LocalPlayer.Character
                if character then
                    local head = character:FindFirstChild("Head")
                    if head then
                        head.LocalTransparencyModifier = 0
                    end
                    for _, accessory in pairs(character:GetChildren()) do
                        if accessory:IsA("Accessory") then
                            local handle = accessory:FindFirstChild("Handle")
                            if handle then
                                handle.LocalTransparencyModifier = 0
                            end
                        end
                    end
                end
            end)
        else
            if AntiConnections["Thirdperson"] then AntiConnections["Thirdperson"]:Disconnect() end
        end
    end
}):AddKeyPicker("ThirdpersonKey", { 
    Default = "V", 
    SyncToggleState = true, 
    Mode = "Toggle", 
    Text = "Third Person", 
    NoUI = false,
    
    Callback = function(Value)

    end
})

VisualsTab:AddSlider("ThirdpersonDistance", {
    Text = "Third Person Distance",
    Default = 19,
    Min = 5,
    Max = 30,
    Rounding = 0,
    Compact = true,
    Tooltip = "How far the camera is in third person."
})
VisualsTab:AddSlider("ThirdpersonOffset", {
    Text = "Third Person Side Offset",
    Default = 0,
    Min = -5,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Tooltip = "Left/right camera shift in third person."
})
VisualsTab:AddSlider("ThirdpersonOffsetUp", {
    Text = "Third Person Height Offset",
    Default = 0,
    Min = -5,
    Max = 5,
    Rounding = 1,
    Compact = true,
    Tooltip = "Up/down camera shift in third person."
})

VisualsTab:AddDivider()


local RunService = game:GetService("RunService")
local camera = workspace.CurrentCamera
local TargetFOV = 70
local CurrentFOV = camera.FieldOfView or 70
local Smoothing = 10 
local Threshold = 0.05

if _G.FOVConnection then _G.FOVConnection:Disconnect() end
_G.FOVConnection = RunService.RenderStepped:Connect(function(dt)
    CurrentFOV = CurrentFOV + (TargetFOV - CurrentFOV) * (1 - math.exp(-Smoothing * dt))
    if math.abs(TargetFOV - CurrentFOV) < Threshold then
        CurrentFOV = TargetFOV
    end
    camera.FieldOfView = CurrentFOV
end)

VisualsTab:AddSlider("FOV", {
    Text = "Field of View",
    Default = 70,
    Min = 0,
    Max = 120,
    Rounding = 1,
    Compact = true,
    Tooltip = "Changes camera field of view smoothly every frame.",
    Callback = function(Value)
        TargetFOV = math.clamp(Value, 0, 120)
    end
})







local EffectsTabe = LeftTabBox:AddTab("Effects") 



EffectsTabe:AddCheckbox("NoVoidEffect", {
    Text = "Anti Void Effect",
    Default = false,
    Disabled = false,
    Tooltip = "Removes void falling effect.",
    Callback = function(Value)
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local entityModules = ReplicatedStorage:FindFirstChild("ModulesClient") and ReplicatedStorage.ModulesClient:FindFirstChild("EntityModules")

        if not entityModules then return end

        local voidModule = entityModules:FindFirstChild("Void") or entityModules:FindFirstChild("_Void")
        if not voidModule then return end

        if Value then
            if voidModule.Name == "Void" then
                voidModule.Name = "_Void"
            end
        else
            if voidModule.Name == "_Void" then
                voidModule.Name = "Void"
            end
        end
    end
})


EffectsTabe:AddCheckbox("NoHasteEffects", {
    Text = "Anti Haste Effects",
    Default = false,
    Disabled = false,
    Tooltip = "Removes red edges when Haste appears.",
    Callback = function(Value)
        if game.ReplicatedStorage.FloorReplicated.ClientRemote:FindFirstChild("Haste") then
            local HasteChanged = game.ReplicatedStorage.FloorReplicated.ClientRemote.Haste.Ambience:GetPropertyChangedSignal("Playing"):Connect(function()
                if Value then
                    game.ReplicatedStorage.FloorReplicated.ClientRemote.Haste.Ambience.Playing = false
                end
            end)
            table.insert(Connections, HasteChanged)
        end
        for _, v in workspace.CurrentCamera:GetChildren() do
            if v.Name == "LiveSanity" and workspace:FindFirstChild("EntityModel") then
                v.Enabled = not Value
            end
        end
    end
})

EffectsTabe:AddCheckbox("AntiFiredamp", {
    Text = "Anti Firedamp",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        local camera = workspace:WaitForChild("Camera")
        local targets = {
            LiveSantity = true,
            LiveFiredamp = true
        }

        local function checkAndDelete(obj)
            if targets[obj.Name] then
                obj:Destroy()
                print("Deleted object: "..obj.Name)
            end
        end

        if _G.AntiFiredampConnection then
            _G.AntiFiredampConnection:Disconnect()
            _G.AntiFiredampConnection = nil
        end

        if Value then
            for _, child in ipairs(camera:GetChildren()) do
                checkAndDelete(child)
            end

            _G.AntiFiredampConnection = camera.ChildAdded:Connect(function(child)
                checkAndDelete(child)
            end)
        end
    end
})



EffectsTabe:AddCheckbox("CaveAtmosphere", {
    Text = "Anti Mines Atmosphere",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        if Value then
            local caveAtmosphere = Lighting:FindFirstChild("CaveAtmosphere")
            if caveAtmosphere then
                caveAtmosphere:Destroy()
            end

            local caves = Lighting:FindFirstChild("Caves")
            if caves then
                caves:Destroy()
            end
        end
    end
})

EffectsTabe:AddCheckbox("Sanity", {
    Text = "Anti Oxygen/Sanity Effects",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        if Value then
            local sanity = Lighting:FindFirstChild("Sanity")
            if sanity then
                sanity:Destroy()
            end

            local oxygenCC = Lighting:FindFirstChild("OxygenCC")
            if oxygenCC then
                oxygenCC:Destroy()
            end

            local oxygenBlur = Lighting:FindFirstChild("OxygenBlur")
            if oxygenBlur then
                oxygenBlur:Destroy()
            end
        end
    end
})





local NotifyGroup = Tabs.Entities:AddLeftGroupbox("Entity Notifications")











local EntityNotifications = {
    ["Screech"] = {Description = "Screech has spawned", Color = Color3.fromRGB(255, 255, 0)},
    ["Halt"] = {Description = "Halt is here", Color = Color3.fromRGB(0, 255, 255)},
    ["FigureRig"] = {Description = "Figure detected", Color = Color3.fromRGB(255, 0, 0)},
    ["Eyes"] = {Description = "Eyes spawned", Color = Color3.fromRGB(127, 30, 220)},
    ["SeekMoving"] = {Description = "Seek spawned", Color = Color3.fromRGB(255, 100, 100)},
    ["RushMoving"] = {Description = "Rush is coming", Color = Color3.fromRGB(0, 255, 0)},
    ["AmbushMoving"] = {Description = "Ambush is approaching", Color = Color3.fromRGB(80, 255, 110)},
    ["A60"] = {Description = "A-60 is rushing", Color = Color3.fromRGB(200, 50, 50)},
    ["A120"] = {Description = "A-120 is near", Color = Color3.fromRGB(55, 55, 55)},
    ["GiggleCeiling"] = {Description = "Giggle is on the ceiling", Color = Color3.fromRGB(200, 200, 200)},
    ["GrumbleRig"] = {Description = "Grumble is patrolling", Color = Color3.fromRGB(150, 150, 150)},
    ["GloombatSwarm"] = {Description = "Gloombat Swarm incoming", Color = Color3.fromRGB(100, 100, 100)},
    ["Dread"] = {Description = "Dread is active", Color = Color3.fromRGB(80, 80, 80)},
    ["BackdoorLookman"] = {Description = "Lookman is watching", Color = Color3.fromRGB(110, 15, 15)},
    ["Snare"] = {Description = "Snare trap spawned", Color = Color3.fromRGB(100, 100, 100)},
    ["WorldLotus"] = {Description = "World Lotus detected", Color = Color3.fromRGB(200, 230, 50)},
    ["Bramble"] = {Description = "Bramble is growing", Color = Color3.fromRGB(50, 150, 30)},
    ["Caws"] = {Description = "Caws are flying", Color = Color3.fromRGB(30, 30, 30)},
    ["Eyestalk"] = {Description = "Eyestalk is GONNA CHASEEEE BOAAAA", Color = Color3.fromRGB(150, 80, 200)},
    ["Grampy"] = {Description = "Grampy is here", Color = Color3.fromRGB(180, 180, 180)},
    ["Groundskeeper"] = {Description = "Groundskeeper is near", Color = Color3.fromRGB(100, 150, 50)},
    ["Mandrake"] = {Description = "Mandrake is screaming", Color = Color3.fromRGB(130, 80, 30)},
    ["Monument"] = {Description = "Monument activated", Color = Color3.fromRGB(150, 150, 150)},
    ["Surge"] = {Description = "Surge is charging", Color = Color3.fromRGB(230, 130, 30)},
    ["BackdoorRush"] = {Description = "BLITZ IS COMING BRO", Color = Color3.fromRGB(230, 130, 30)},
    ["LiveEntityBramble"] = {Description = "Live Bramble is growing", Color = Color3.fromRGB(50, 150, 30)},
}

local modelToDisplay = {
    ["Screech"] = "Screech",
    ["Halt"] = "Halt",
    ["FigureRig"] = "Figure",
    ["Eyes"] = "Eyes",
    ["SeekMoving"] = "Seek",
    ["RushMoving"] = "Rush",
    ["AmbushMoving"] = "Ambush",
    ["A60"] = "A-60",
    ["A120"] = "A-120",
    ["GiggleCeiling"] = "Giggle",
    ["GrumbleRig"] = "Grumble",
    ["GloombatSwarm"] = "Gloombat Swarm",
    ["Dread"] = "Dread",
    ["BackdoorLookman"] = "Lookman",
    ["Snare"] = "Snare",
    ["WorldLotus"] = "World Lotus",
    ["Bramble"] = "Bramble",
    ["Caws"] = "Caws",
    ["Eyestalk"] = "Eyestalk",
    ["Grampy"] = "Grampy",
    ["Groundskeeper"] = "Groundskeeper",
    ["Mandrake"] = "Mandrake",
    ["Monument"] = "Monument",
    ["Surge"] = "Surge",
    ["BackdoorRush"] = "Blitz",
    ["LiveEntityBramble"] = "Live Bramble",
}

local displayToModel = {}
for model, display in pairs(modelToDisplay) do
    displayToModel[display] = model
end

local displayList = {}
for model, display in pairs(modelToDisplay) do
    table.insert(displayList, display)
end
table.sort(displayList)

NotifyGroup:AddDropdown("NotifyEntitiesDropdown", {
    Text = "Notify on Entity Spawn",
    Default = {},
    Multi = true,
    Values = displayList,
    Callback = function(selectedEntities)
        if AntiConnections["NotifyEntities"] then
            AntiConnections["NotifyEntities"]:Disconnect()
            AntiConnections["NotifyEntitiesRooms"]:Disconnect()
        end

        if next(selectedEntities) then
            local selectedModels = {}
            for display in pairs(selectedEntities) do
                local model = displayToModel[display]
                if model then
                    selectedModels[model] = true
                end
            end

            AntiConnections["NotifyEntities"] = workspace.ChildAdded:Connect(function(child)
                if child:IsA("Model") and EntityNotifications[child.Name] and selectedModels[child.Name] then
                    Library:Notify(EntityNotifications[child.Name].Description, 5)
                end
            end)

            AntiConnections["NotifyEntitiesRooms"] = Rooms.DescendantAdded:Connect(function(desc)
                if desc:IsA("Model") and EntityNotifications[desc.Name] and selectedModels[desc.Name] then
                    Library:Notify(EntityNotifications[desc.Name].Description, 5)
                end
            end)
        end
    end
})






local AntiGroup = Tabs.Entities:AddRightGroupbox("Anti Entities")



AntiConnections = AntiConnections or {}

AntiGroup:AddCheckbox("AntiScreech", {
    Text = "Avoid Screech",
    Default = false,
    Disabled = false,
    Callback = function(on)
        if on then
            for _,inst in ipairs(workspace:GetDescendants()) do
                if inst.Name == "Screech" then pcall(function() inst:Destroy() end) end
            end
            AntiConnections.Screech = workspace.DescendantAdded:Connect(function(inst)
                if inst.Name == "Screech" then
                    task.defer(function() if inst and inst.Parent then pcall(function() inst:Destroy() end) end end)
                end
            end)
        else
            if AntiConnections.Screech then AntiConnections.Screech:Disconnect(); AntiConnections.Screech = nil end
        end
    end
})

local connection


AntiGroup:AddCheckbox("AntiGloomPile", {
    Text = "Anti Gloom Eggs",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        if getgenv().AntiGloomConn then
            getgenv().AntiGloomConn:Disconnect()
            getgenv().AntiGloomConn = nil
        end

        local rooms = workspace:WaitForChild("CurrentRooms")

        if Value then
            for _, v in ipairs(rooms:GetDescendants()) do
                if v.Name == "GloomEgg" then
                    local egg = v:FindFirstChild("Egg")
                    if egg then egg.CanTouch = false end
                end
            end

            getgenv().AntiGloomConn = rooms.DescendantAdded:Connect(function(v)
                if v.Name == "GloomEgg" then
                    local egg = v:WaitForChild("Egg", 9e9)
                    egg.CanTouch = false
                elseif v.Name == "Egg" and v.Parent and v.Parent.Name == "GloomEgg" then
                    v.CanTouch = false
                end
            end)
        else
            for _, v in ipairs(rooms:GetDescendants()) do
                if v.Name == "GloomEgg" then
                    local egg = v:FindFirstChild("Egg")
                    if egg then egg.CanTouch = true end
                end
            end
        end
    end
})


AntiGroup:AddCheckbox("AntiDread", {
    Text = "Avoid Dread",
    Default = false,
    Disabled = false,
    Callback = function(isEnabled)
        local player = game:GetService("Players").LocalPlayer
        local modules = player.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener.Modules

        local dreadModule = modules:FindFirstChild("Dread") or modules:FindFirstChild("_Dread")
        if dreadModule then
            dreadModule.Name = isEnabled and "_Dread" or "Dread"
        end
    end
})

AntiGroup:AddCheckbox("AntiGiggle", {
    Text = "Anti Giggle",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        if getgenv().AntiGiggleConn then
            getgenv().AntiGiggleConn:Disconnect()
            getgenv().AntiGiggleConn = nil
        end

        local rooms = workspace:WaitForChild("CurrentRooms")

        if Value then
            for _, v in ipairs(rooms:GetDescendants()) do
                if v.Name == "GiggleCeiling" then
                    local hitbox = v:FindFirstChild("Hitbox")
                    if hitbox then hitbox.CanTouch = false end
                end
            end

            getgenv().AntiGiggleConn = rooms.DescendantAdded:Connect(function(v)
                if v.Name == "GiggleCeiling" then
                    local hitbox = v:WaitForChild("Hitbox", 9e9)
                    hitbox.CanTouch = false
                elseif v.Name == "Hitbox" and v.Parent and v.Parent.Name == "GiggleCeiling" then
                    v.CanTouch = false
                end
            end)
        else
            for _, v in ipairs(rooms:GetDescendants()) do
                if v.Name == "GiggleCeiling" then
                    local hitbox = v:FindFirstChild("Hitbox")
                    if hitbox then hitbox.CanTouch = true end
                end
            end
        end
    end
})


AntiGroup:AddCheckbox("NoHidingVignette", {
    Text = "Avoid Hiding Edges",
    Default = false,
    Disabled = false,
    Tooltip = "Removes dark edges when hiding.",
    Callback = function(Value)
        LocalPlayer.PlayerGui.MainUI.MainFrame.HideVignette.Image = Value and "rbxassetid://0" or "rbxassetid://6100076320"
    end
})

local RunService = game:GetService("RunService")
local crouchConnection

AntiGroup:AddCheckbox("AntiFigure", {
    Text = "Avoid Figure hearing",
    Default = false,
    Disabled = false,
    Tooltip = "Makes the game think you're crouching",
    Callback = function(Value)
        isCrouching = Value

        if crouchConnection then
            crouchConnection:Disconnect()
            crouchConnection = nil
        end

        if Value then
            crouchConnection = RunService.Heartbeat:Connect(function()
                ReplicatedStorage.RemotesFolder.Crouch:FireServer(true)
            end)
        else
            ReplicatedStorage.RemotesFolder.Crouch:FireServer(false)
        end
    end
})

AntiGroup:AddCheckbox("NoSurge", {
    Text = "Avoid Surge",
    Default = false,
    Disabled = false,
    Tooltip = "Credits to jack for the line",
    Callback = function(Value)
        if Value then
            local surgeClient = game.ReplicatedStorage:WaitForChild("FloorReplicated"):WaitForChild("ClientRemote"):FindFirstChild("SurgeClient")
            if surgeClient then
                surgeClient:Destroy()
            end
        end
    end
})


local ReplicatedStorage = game:GetService("ReplicatedStorage")

AntiGroup:AddCheckbox("AntiHalt", {
    Text = "Avoid Halt",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        local entityModules = game:GetService("ReplicatedStorage"):WaitForChild("ModulesClient"):WaitForChild("EntityModules")
        if Value then
            local shade = entityModules:FindFirstChild("Shade")
            if shade and shade:IsA("ModuleScript") then
                shade.Name = "_Shade"
            end
        else
            local shade = entityModules:FindFirstChild("_Shade")
            if shade and shade:IsA("ModuleScript") then
                shade.Name = "Shade"
            end
        end
    end
})








local RunService = game:GetService("RunService")

AntiGroup:AddCheckbox("AntiLookman", {
    Text = "Avoid Lookman",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        if Value then
            if alive then
                if Workspace:FindFirstChild("BackdoorLookman") then
                    RemoteFolder.MotorReplication:FireServer(-890)
                end
            end
        end
    end
})



AntiGroup:AddCheckbox('AntiSnare', {
	Text = "Avoid Snare",
	Default = false,
	Callback = function(Value)
		local currentRooms = workspace:WaitForChild("CurrentRooms")

		local function handleSnare(snare)
			if snare.Name == "Snare" then
				local hitbox = snare:FindFirstChild("Hitbox")
				if hitbox then
					hitbox.CanTouch = not Value
				else
					snare.ChildAdded:Connect(function(child)
						if child.Name == "Hitbox" then
							child.CanTouch = not Value
						end
					end)
				end
			end
		end

		for _, v in ipairs(currentRooms:GetDescendants()) do
			handleSnare(v)
		end

		currentRooms.DescendantAdded:Connect(handleSnare)
	end
})

AntiGroup:AddCheckbox("AntiSeekArmsChandelier", {
    Text = "Avoid Seek Obstacles",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        if Value then
            AntiConnections["SeekArmsChandelier"] = Rooms.DescendantAdded:Connect(function(desc)
                if desc.Name == "Seek_Arm" then
                    desc:WaitForChild("AnimatorPart", 9e9)
                    desc.AnimatorPart.CanTouch = false
                    desc.AnimatorPart.Transparency = 1
                    for _, part in desc:GetDescendants() do
                        if part:IsA("BasePart") then
                            part.Transparency = 1
                        end
                    end
                elseif desc.Name == "ChandelierObstruction" then
                    desc:WaitForChild("HurtPart", 9e9)
                    desc.HurtPart.CanTouch = false
                    desc.HurtPart.Transparency = 1
                    for _, part in desc:GetDescendants() do
                        if part:IsA("BasePart") then
                            part.Transparency = 1
                        end
                    end
                end
            end)
            for _, v in Rooms:GetDescendants() do
                if v.Name == "Seek_Arm" and v:IsA("Model") then
                    v:WaitForChild("AnimatorPart", 9e9)
                    v.AnimatorPart.CanTouch = false
                    v.AnimatorPart.Transparency = 1
                    for _, part in v:GetDescendants() do
                        if part:IsA("BasePart") then
                            part.Transparency = 1
                        end
                    end
                elseif v.Name == "ChandelierObstruction" and v:IsA("Model") then
                    v:WaitForChild("HurtPart", 9e9)
                    v.HurtPart.CanTouch = false
                    v.HurtPart.Transparency = 1
                    for _, part in v:GetDescendants() do
                        if part:IsA("BasePart") then
                            part.Transparency = 1
                        end
                    end
                end
            end
        else
            if AntiConnections["SeekArmsChandelier"] then AntiConnections["SeekArmsChandelier"]:Disconnect() end
            for _, v in Rooms:GetDescendants() do
                if v.Name == "Seek_Arm" and v:IsA("Model") then
                    v:WaitForChild("AnimatorPart", 9e9)
                    v.AnimatorPart.CanTouch = true
                    v.AnimatorPart.Transparency = 0
                    for _, part in v:GetDescendants() do
                        if part:IsA("BasePart") then
                            part.Transparency = 0
                        end
                    end
                elseif v.Name == "ChandelierObstruction" and v:IsA("Model") then
                    v:WaitForChild("HurtPart", 9e9)
                    v.HurtPart.CanTouch = true
                    v.HurtPart.Transparency = 0
                    for _, part in v:GetDescendants() do
                        if part:IsA("BasePart") then
                            part.Transparency = 0
                        end
                    end
                end
            end
        end
    end
})


AntiGroup:AddCheckbox("AntiDupe", {
    Text = "Avoid Dupe",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
            if v.Name == "DoorFake" then
                v:WaitForChild("Hidden").CanTouch = not Value
                local lock = v:FindFirstChild("Lock")
                if lock then
                    local prompt = lock:FindFirstChildOfClass("ProximityPrompt")
                    if prompt then
                        prompt.ClickablePrompt = not Value
                    end
                end
            end
        end
    end
})


AntiGroup:AddCheckbox("AntiVacuum", {
    Text = "Avoid Vacuum",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        for _, v in ipairs(workspace.CurrentRooms:GetDescendants()) do
            if v.Name == "SideroomSpace" then
                for _, part in ipairs(v:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.CanTouch = not Value
                        part.CanCollide = Value
                    end
                end
            end
        end
    end
})



AntiGroup:AddCheckbox("AntiEyes", {
    Text = "Avoid Eyes",
    Default = false,
    Disabled = false,
    Tooltip = "Automatically looks down when Eyes spawns to prevent damage.",
    Callback = function(Value)
        if Value then
            Connections.AntiEyes = game:GetService("RunService").RenderStepped:Connect(function()
                if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
                if not LocalPlayer.Character:GetAttribute("Hiding") then
                    for _, v in pairs(workspace:GetChildren()) do
                        if v.Name == "Eyes" and v:FindFirstChild("Core") and v.Core:FindFirstChild("Ambience") and v.Core.Ambience.Playing then
                            game.ReplicatedStorage.RemotesFolder.MotorReplication:FireServer(-650)
                            break
                        end
                    end
                end
            end)
        else
            if Connections.AntiEyes then
                Connections.AntiEyes:Disconnect()
                Connections.AntiEyes = nil
            end
        end
    end
})



local BringGroup = Tabs.Misc:AddRightGroupbox("Fun")
BringGroup:AddButton("EnableStarrift", {
	Text = "Enable Star Rift",
	Visible = true,
	Func = function()
		local lighting = game:GetService("Lighting")
		local currentRooms = workspace:FindFirstChild("CurrentRooms")
		if not currentRooms then 
			Library:Notify("Star Rift not found. Go to Room 100 or the Mines", 2)
			return 
		end

		local found = false

		for _, room in ipairs(currentRooms:GetChildren()) do
			local riftSpawn = room:FindFirstChild("RiftSpawn")
			if riftSpawn then
				local rift = riftSpawn:FindFirstChild("Rift")
				if rift then
					local starCenter = rift:FindFirstChild("StarCenter")
					if starCenter then
						found = true

						local innerRift = starCenter:FindFirstChild("Rift")
						if innerRift and innerRift:IsA("BasePart") then
							innerRift.Transparency = 0
						end

						local prompt = starCenter:FindFirstChild("StarRiftPrompt")
						if prompt and prompt:IsA("ProximityPrompt") then
							prompt.Enabled = true
						end

						local attachment = starCenter:FindFirstChild("Attachment")
						if attachment then
							local light = attachment:FindFirstChildOfClass("PointLight")
							if light then
								light.Brightness = 1
							end
						end

						local particles = starCenter:FindFirstChild("ParticlesIn")
						if particles then
							for _, name in ipairs({ "Core", "RainbowShards", "Triangles", "ZoomParticle" }) do
								local emitter = particles:FindFirstChild(name)
								if emitter and emitter:IsA("ParticleEmitter") then
									emitter.Enabled = true
								end
							end
						end
					end
				end
			end
		end

		if not found then
			Library:Notify("Star Rift not found. Go to Room 100 or the Mines", 2)
		end
	end
})

BringGroup:AddButton({
    Text = "Get Glitch Cube",
    Func = function()
        Library:Notify("TURN NOCLIP ON!", 2)
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        local progress = 0
        local maxProgress = 100
        local progressIncrement = 20
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local glitchScreen = player.PlayerGui.MainUI.MainFrame.GlitchScreen
        local isActive = true
        local glitchActive = false
        
        local function onGlitchDetected()
            if not glitchActive and progress < maxProgress then
                glitchActive = true
                progress = progress + progressIncrement
                Library:Notify(progress .. "% done", 2)
                
                if progress >= maxProgress then
                    isActive = false
                    Library:Notify("Completed.", 3)
                end
                
                task.wait(2)
                glitchActive = false
            end
        end
        
        local function monitorGlitchScreen()
            glitchScreen:GetPropertyChangedSignal("Visible"):Connect(function()
                if glitchScreen.Visible then
                    onGlitchDetected()
                end
            end)
        end
        
        pcall(monitorGlitchScreen)
        task.spawn(function()
            while isActive do
                if character and character.Parent and humanoid and humanoid.Parent then
                    humanoid.HipHeight = 20
                    task.wait(1) 
                    humanoid.HipHeight = 2.1
                else
                    character = player.Character or player.CharacterAdded:Wait()
                    humanoid = character:WaitForChild("Humanoid")
                end
                
                task.wait(0.1)
            end
        end)
        player.CharacterAdded:Connect(function(newCharacter)
            character = newCharacter
            humanoid = character:WaitForChild("Humanoid")
        end)
    end
})


BringGroup:AddButton({
    Text = "Get NVCS-3000",
    Func = function()
        _G.scanner_fps = 60
        _G.disable_static = false
        loadstring(game:HttpGet("https://raw.githubusercontent.com/notpoiu/Scripts/main/Scanner.lua"))()
    end
})









local WALL_DISTANCE = 7
local WALL_SIZE = Vector3.new(12, 12, 12)
local WALL_COLOR = Color3.fromRGB(0, 0, 0)
local WALL_TRANSPARENCY = 1

local function createWallInFrontOfDoor()
    local currentRooms = workspace:FindFirstChild("CurrentRooms")
    if not currentRooms then return end
    local room0 = currentRooms:FindFirstChild("0")
    if not room0 then return end
    local door = room0:FindFirstChild("Door")
    if not door then return end

    local doorCFrame
    if door:IsA("Model") then
        if door.PrimaryPart then
            doorCFrame = door.PrimaryPart.CFrame
        else
            local firstPart = door:FindFirstChildOfClass("Part") or door:FindFirstChildOfClass("MeshPart")
            if firstPart then doorCFrame = firstPart.CFrame else return end
        end
    elseif door:IsA("BasePart") then
        doorCFrame = door.CFrame
    else
        return
    end

    local wallCFrame = doorCFrame * CFrame.new(0, 0, -WALL_DISTANCE) * CFrame.Angles(0, math.rad(90), 0)

    local wall = Instance.new("Part")
    wall.Name = "SpawnedWall"
    wall.Size = WALL_SIZE
    wall.CFrame = wallCFrame
    wall.Color = WALL_COLOR
    wall.Transparency = WALL_TRANSPARENCY
    wall.Material = Enum.Material.Plastic
    wall.TopSurface = Enum.SurfaceType.Smooth
    wall.BottomSurface = Enum.SurfaceType.Smooth
    wall.CanCollide = false
    wall.Anchored = true
    wall.Parent = room0
    return wall
end

local isActive = false
local connection
local screenGui
local runServiceConnection

BringGroup:AddButton("speedrun", { 
    Text = "spreedrun timer", 
    Default = false, 
    Func = function()
        if isActive then
            Library:Notify("already enabled bro", 2)
            return
        end
        isActive = true
        local success, wall = pcall(createWallInFrontOfDoor)
        if not success or not wall then
            isActive = false
            return
        end
        local hasTriggered = false
        connection = wall.Touched:Connect(function()
            if hasTriggered then return end
            hasTriggered = true
            local player = game.Players.LocalPlayer
            if not player then return end
            local playerGui = player:WaitForChild("PlayerGui", 5)
            if not playerGui then return end
            screenGui = Instance.new("ScreenGui", playerGui)
            local textButton = Instance.new("TextButton", screenGui)
            textButton.Size = UDim2.new(0.2, 0, 0.05, 0)
            textButton.Position = UDim2.new(0.4, 0, 0.02, 0)
            textButton.Text = "00:00:00.000"
            textButton.TextSize = 14
            textButton.BackgroundTransparency = 0.5
            textButton.BackgroundColor3 = Color3.new(0, 0, 0)
            textButton.TextColor3 = Color3.new(1, 1, 1)
            local startTime = tick()
            runServiceConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not textButton or not textButton.Parent then
                    runServiceConnection:Disconnect()
                    return
                end
                local elapsed = tick() - startTime
                local hours = math.floor(elapsed / 3600)
                elapsed = elapsed % 3600
                local minutes = math.floor(elapsed / 60)
                local seconds = math.floor(elapsed % 60)
                local milliseconds = math.floor((elapsed % 1) * 1000)
                textButton.Text = string.format("%02d:%02d:%02d.%03d", hours, minutes, seconds, milliseconds)
            end)
            if connection then
                connection:Disconnect()
                connection = nil
            end
            if wall then
                wall:Destroy()
            end
        end)
    end
})











BringGroup:AddDivider()




BringGroup:AddLabel('<font color="rgb(255, 255, 255)"><b>actually not that fun stuff</b></font>')





BringGroup:AddButton({
	Text = "Revive",
	Func = function()
		game.ReplicatedStorage.RemotesFolder.Revive:FireServer()
	end,
})

BringGroup:AddButton({
    Text = "Reset Character",
    Func = function()
        local player = game.Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.Health = 0
        end
    end
})

BringGroup:AddButton({
	Text = "Lobby",
	Func = function()
		game.ReplicatedStorage.RemotesFolder.Lobby:FireServer()
	end,
})

BringGroup:AddButton({
	Text = "Play Again",
	Func = function()
		game.ReplicatedStorage.RemotesFolder.PlayAgain:FireServer()
	end,
})

local CheatStuff = Tabs.Misc:AddLeftGroupbox("Cheats")
local EntityDistances = {
    ["RushMoving"] = 50,
    ["BackdoorRush"] = 50,
    ["AmbushMoving"] = 100,
    ["A60"] = 100,
    ["A120"] = 35
}

local Rooms = workspace.CurrentRooms
local LocalPlayer = game.Players.LocalPlayer

local function GetHiding()
    local Closest
    local Prompt

    local currRoom = Rooms and Rooms[LocalPlayer:GetAttribute("CurrentRoom")]
    if not currRoom then return nil end
    local char = LocalPlayer.Character
    if not char then return nil end
    local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Collision") or char.PrimaryPart
    if not hrp then return nil end

    local function distFromPlayer(model)
        if not model then return math.huge end
        local part = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart", true)
        if not part then return math.huge end
        return (part.Position - hrp.Position).Magnitude
    end

    local assets = currRoom:FindFirstChild("Assets")
    if assets then
        for _, v in pairs(assets:GetChildren()) do
            if v:IsA("Model") then
                if (v.Name == "Locker_Large" or v.Name == "Wardrobe" or v.Name == "Toolshed" or v.Name == "Bed" or v.Name == "Rooms_Locker" or v.Name == "Rooms_Locker_Fridge" or v.Name == "Backdoor_Wardrobe")
                    and v:FindFirstChild("HidePrompt") and v:FindFirstChild("HiddenPlayer") then
                    if not v.HiddenPlayer.Value and not v:FindFirstChild("HideEntityOnSpot", true) then
                        if Closest then
                            if distFromPlayer(v) < distFromPlayer(Closest) then
                                Closest = v
                                Prompt = v.HidePrompt
                            end
                        else
                            Closest = v
                            Prompt = v.HidePrompt
                        end
                    end
                elseif v.Name == "Double_Bed" then
                    for _, x in pairs(v:GetChildren()) do
                        if x.Name == "DoubleBed" and x:FindFirstChild("HidePrompt") and x:FindFirstChild("HiddenPlayer") then
                            if not x.HiddenPlayer.Value and not x:FindFirstChild("HideEntityOnSpot", true) then
                                if Closest then
                                    if distFromPlayer(x) < distFromPlayer(Closest) then
                                        Closest = x
                                        Prompt = x.HidePrompt
                                    end
                                else
                                    Closest = x
                                    Prompt = x.HidePrompt
                                end
                            end
                        end
                    end
                elseif v.Name == "Dumpster" then
                    for _, x in pairs(v:GetChildren()) do
                        if x:FindFirstChild("HidePrompt") and x:FindFirstChild("HiddenPlayer") then
                            local dumpsterBaseHasSpot = v:FindFirstChild("DumpsterBase") and v.DumpsterBase:FindFirstChild("HideEntityOnSpot")
                            if not x.HiddenPlayer.Value and not dumpsterBaseHasSpot then
                                if Closest then
                                    if distFromPlayer(x) < distFromPlayer(Closest) then
                                        Closest = x
                                        Prompt = x.HidePrompt
                                    end
                                else
                                    Closest = x
                                    Prompt = x.HidePrompt
                                end
                            end
                        end
                    end
                end
            elseif v:IsA("Folder") then
                if v.Name == "Blockage" then
                    for _, x in pairs(v:GetChildren()) do
                        if x:IsA("Model") and x.Name == "Wardrobe" and x:FindFirstChild("HiddenPlayer") and x:FindFirstChild("HidePrompt") then
                            if not x.HiddenPlayer.Value then
                                if Closest then
                                    if distFromPlayer(x) < distFromPlayer(Closest) then
                                        Closest = x
                                        Prompt = x.HidePrompt
                                    end
                                else
                                    Closest = x
                                    Prompt = x.HidePrompt
                                end
                            end
                        end
                    end
                elseif v.Name == "Vents" then
                    for _, x in pairs(v:GetChildren()) do
                        if x.Name == "CircularVent" and x:FindFirstChild("Grate") and x.Grate:FindFirstChild("HidePrompt") and x:FindFirstChild("HiddenPlayer") then
                            if not x.HiddenPlayer.Value and not v:FindFirstChild("HideEntityOnSpot", true) then
                                if Closest then
                                    if distFromPlayer(x) < distFromPlayer(Closest) then
                                        Closest = x
                                        Prompt = x.Grate.HidePrompt
                                    end
                                else
                                    Closest = x
                                    Prompt = x.Grate.HidePrompt
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    for _, v in pairs(currRoom:GetChildren()) do
        if v:IsA("Model") then
            if v.Name == "CircularVent" and v:FindFirstChild("Grate") and v.Grate:FindFirstChild("HidePrompt") and v:FindFirstChild("HiddenPlayer") then
                if not v.HiddenPlayer.Value and not v:FindFirstChild("HideEntityOnSpot", true) then
                    if Closest then
                        if distFromPlayer(v) < distFromPlayer(Closest) then
                            Closest = v
                            Prompt = v.Grate.HidePrompt
                        end
                    else
                        Closest = v
                        Prompt = v.Grate.HidePrompt
                    end
                end
            end
        end
    end

    return Prompt
end

CheatStuff:AddCheckbox("AutoHide", {
    Text = "Auto Hide V2",
    Default = false,
    Disabled = false,
    Risky = true,
    Tooltip = "hides for you, couldnt you guess it",
    Callback = function(Value) end
})
CheatStuff:AddDropdown("HidingType", { 
    Text = "Auto Hide Mode", 
    Default = "Safety", 
    Multi = false, 
    Values = {"Safety", "Close Call"}, 
    Callback = function(Value) end 
})
CheatStuff:AddSlider("PredictionTime", {
    Text = "Prediction Time",
    Default = 1.5,
    Min = 0.1,
    Max = 1.5,
    Rounding = 2,
    Compact = true,
    Suffix = "s",
    Callback = function(Value) end
})

CheatStuff:AddSlider("DistanceMultiplier", {
    Text = "Distance Multiplier",
    Default = 1,
    Min = 1,
    Max = 1.5,
    Rounding = 1,
    Compact = true,
    Suffix = "x",
    Callback = function(Value) end
})



task.spawn(function()
    local Connections = {}
    table.insert(Connections, workspace.ChildAdded:Connect(function(v)
        if v:IsA("Model") and EntityDistances[v.Name] then
            task.wait(1)
            local Part = v.PrimaryPart or v:FindFirstChildWhichIsA("BasePart", true)
            if not Part then return end
            v:SetAttribute("_Prediction", Part.Position)

            while task.wait() and v.Parent do
                task.spawn(function()
                    local LastPosition = Part.Position
                    task.wait(1 / 3)
                    if Part and Part.Parent then
                        v:SetAttribute("_Prediction", Part.Position - LastPosition)
                    end
                end)

                if Toggles and Toggles.AutoHide and Toggles.AutoHide.Value then
                    local IncludeList = {}
                    for _, Room in pairs(Rooms:GetChildren()) do
                        if Room:FindFirstChild("Assets") then
                            table.insert(IncludeList, Room.Assets)
                        end
                        if Room:FindFirstChild("Parts") then
                            table.insert(IncludeList, Room.Parts)
                        end
                    end

                    local RaycastParams = RaycastParams.new()
                    RaycastParams.FilterDescendantsInstances = IncludeList
                    RaycastParams.FilterType = Enum.RaycastFilterType.Include

                    local Count = {0.2, 0.4, 0.6, 0.8, 1}
                    local entityInRange = false

                    for i = 1, #Count do
                        local Number = (Options and Options.PredictionTime and Options.PredictionTime.Value) or 0.5
                        Number = Number * Count[i]
                        local predAttr = v:GetAttribute("_Prediction")
                        local Prediction = (predAttr and predAttr * 3) or Vector3.new(0,0,0)
                        Prediction = Prediction * Number

                        local char = LocalPlayer.Character
                        if not char then break end
                        local hrp = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Collision") or char.PrimaryPart
                        if not hrp then break end

                        if Vector3.new(Prediction.X, 0, Prediction.Z).Magnitude > 1 then
                            local PredictionPosition = Part.Position + Prediction
                            local Raycast
                            if Toggles.GA_AutoHide_VisCheck and Toggles.GA_AutoHide_VisCheck.Value then
                                Raycast = workspace:Raycast(hrp.Position, PredictionPosition - hrp.Position, RaycastParams)
                            end

                            local distMultiplier = (Options and Options.DistanceMultiplier and Options.DistanceMultiplier.Value) or 1
                            local mode = (Options and Options.HidingType and Options.HidingType.Value) or "Safety"
                            local adjust = 0
                            if mode == "Safety" then
                                adjust = 20
                            elseif mode == "Close Call" then
                                adjust = -20
                            end
                            local adjustedDistance = EntityDistances[v.Name] + adjust
                            local distanceToEntity = (PredictionPosition - hrp.Position).Magnitude

                            if (not Raycast) and distanceToEntity <= (adjustedDistance * distMultiplier) then
                                entityInRange = true
                                local Prompt = GetHiding()
                                if Prompt then
                                    pcall(function() fireproximityprompt(Prompt) end)
                                end
                                break
                            end
                        end
                    end

                    local char = LocalPlayer.Character
                    if char and not entityInRange and char:GetAttribute("Hiding") then
                        char:SetAttribute("Hiding", false)
                    end
                end
            end
        end
    end))
end)

CheatStuff:AddDivider()

CheatStuff:AddCheckbox("NoCutscenes", {
	Text = "No Cutscenes",
	Default = false,
    Disabled = false,
	Callback = function(Value)
		local player = game:GetService("Players").LocalPlayer
		local RemoteListener = player.PlayerGui.MainUI.Initiator.Main_Game:WaitForChild("RemoteListener")

		local CutScenes = RemoteListener:FindFirstChild("Cutscenes") or RemoteListener:FindFirstChild("_Cutscenes")
		if not CutScenes then
			CutScenes = RemoteListener:WaitForChild("Cutscenes", 3) or RemoteListener:WaitForChild("_Cutscenes", 3)
		end

		if CutScenes then
			CutScenes.Name = Value and "_Cutscenes" or "Cutscenes"
		end
	end
})

CheatStuff:AddDivider()













CheatStuff:AddCheckbox("InfCrucifix", {
    Text = "Infinite Crucifix",
    Default = false,
    Disabled = false,
    Risky = true,
    Callback = function(Value)
        local Replicated = game:GetService("ReplicatedStorage")
        local RemoteFolder = Replicated:FindFirstChild("EntityInfo")
            or Replicated:FindFirstChild("RemotesFolder")
            or Replicated:FindFirstChild("Bricks")
        if not RemoteFolder then return end

        local DropItem = RemoteFolder:FindFirstChild("DropItem")
        if not DropItem then return end

        local player = game.Players.LocalPlayer
        local Run = game:GetService("RunService")

        local rayparams = RaycastParams.new()
        rayparams.FilterType = Enum.RaycastFilterType.Exclude
        rayparams.FilterDescendantsInstances = {player.Character, workspace.CurrentRooms}

        local distances = {
            RushMoving = 54,
            AmbushMoving = 67,
            A60 = 70
        }

        local conn
        local lastDrop = 0

        local function findCrucifixTool()
            local c = player.Character
            if c then
                for _, child in ipairs(c:GetChildren()) do
                    if child:IsA("Tool") and child.Name:lower():find("crucifix", 1, true) then
                        return child
                    end
                end
            end
            return nil
        end

        local function fireInteract(p)
            if not p then return end
            pcall(fireproximityprompt, p)
        end

        if not Value then
            if conn then
                conn:Disconnect()
                conn = nil
            end
            return
        end

        conn = Run.RenderStepped:Connect(function(dt)
            if not Value then return end

            local currentTime = os.clock()
            if currentTime - lastDrop < 1 then return end

            local char = player.Character
            local root = char and (char:FindFirstChild("CollisionPart") or char:FindFirstChild("HumanoidRootPart"))
            if not root then return end

            for _, v in ipairs(workspace:GetChildren()) do
                local d = distances[v.Name]
                if d and v.PrimaryPart then
                    v.PrimaryPart.CanCollide = true
                    v.PrimaryPart.CanQuery = true
                    local pt = root.Position
                    local dir = v.PrimaryPart.Position - pt
                    local hit = workspace:Raycast(pt, dir, rayparams)
                    if hit and hit.Instance:IsDescendantOf(v) then
                        if (pt - v.PrimaryPart.Position).Magnitude < d then
                            local tool = findCrucifixTool()
                            if tool then
                                lastDrop = currentTime
                                local drops = workspace:FindFirstChild("Drops") or workspace:WaitForChild("Drops", 5)
                                if drops then
                                    local pickConn
                                    pickConn = drops.ChildAdded:Connect(function(droppedItem)
                                        if droppedItem.Name == "Crucifix" then
                                            pickConn:Disconnect()
                                            local p = droppedItem:WaitForChild("ModulePrompt", 3) or droppedItem:FindFirstChildOfClass("ProximityPrompt")
                                            if p then
                                                repeat
                                                    fireInteract(p)
                                                    task.wait()
                                                until not droppedItem:IsDescendantOf(workspace)
                                            end
                                        end
                                    end)
                                end
                                DropItem:FireServer(tool)
                            end
                        end
                    end
                end
            end
        end)
    end
})



CheatStuff:AddCheckbox("InfItems", {
    Text = "Infinite Items",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        local Replicated = game:GetService("ReplicatedStorage")
        local RemoteFolder = Replicated:FindFirstChild("EntityInfo")
            or Replicated:FindFirstChild("RemotesFolder")
            or Replicated:FindFirstChild("Bricks")
        if not RemoteFolder then return end

        local DropItem = RemoteFolder:FindFirstChild("DropItem")
        if not DropItem then return end

        local player = game.Players.LocalPlayer
        local Run = game:GetService("RunService")
        local roomFolder = workspace:FindFirstChild("CurrentRooms")
        if not roomFolder then return end

        local function fireInteract(p)
            if p then pcall(fireproximityprompt, p) end
        end

        local function findToolByName(search)
            search = search:lower()
            local c = player.Character
            if c then
                for _, child in ipairs(c:GetChildren()) do
                    if child:IsA("Tool") and child.Name:lower():find(search, 1, true) then
                        return child
                    end
                end
            end
            for _, child in ipairs(player.Backpack:GetChildren()) do
                if child:IsA("Tool") and child.Name:lower():find(search, 1, true) then
                    return child
                end
            end
            return nil
        end

        local function addFake(O, aK)
            if not O or not O:IsA("ProximityPrompt") or O:GetAttribute("HasFake") then return end
            O:SetAttribute("HasFake", true)
            local aL = O:Clone()
            aL.Name = "FakePrompt"
            aL.Parent = O.Parent
            aL.Enabled = true
            aL.ClickablePrompt = true
            O.Enabled = false
            O.ClickablePrompt = false

            aL.Triggered:Connect(function()
                local toolSearch = aK:lower()
                local toolInst = findToolByName(toolSearch)
                if not toolInst then return end

                DropItem:FireServer(toolInst)

                local con
                local timedOut = false
                task.delay(1, function() timedOut = true end)
                con = workspace.Drops.ChildAdded:Connect(function(v)
                    if timedOut then
                        con:Disconnect()
                        return
                    end
                    local newPrompt = v:FindFirstChildOfClass("ProximityPrompt")
                    if newPrompt then
                        if aK == "Lockpick" then
                            fireInteract(newPrompt)
                            fireInteract(O)
                        elseif aK == "Shears" then
                            fireInteract(O)
                            fireInteract(newPrompt)
                        else
                            fireInteract(newPrompt)
                            fireInteract(O)
                        end
                        task.wait(0.25)
                        con:Disconnect()
                    end
                end)
            end)
        end

        local function scanPrompts(parentsMap, namesMap)
            local found = {}
            for _, v in ipairs(roomFolder:GetDescendants()) do
                if v:IsA("ProximityPrompt") and (parentsMap[v.Parent.Name] or namesMap[v.Name]) then
                    table.insert(found, v)
                end
            end
            return found
        end

        local function cleanupEnableReal()
            for _, v in ipairs(roomFolder:GetDescendants()) do
                if v.Name == "FakePrompt" and v.Parent then
                    v:Destroy()
                elseif v:IsA("ProximityPrompt") and v.Name ~= "FakePrompt" then
                    pcall(function()
                        v.Enabled = true
                        v.ClickablePrompt = true
                        if v:GetAttribute("HasFake") == true then
                            v:SetAttribute("HasFake", nil)
                        end
                    end)
                end
            end
        end

        local LockpickParents = {ChestBoxLocked = true, Locker_Small_Locked = true, Toolbox_Locked = true}
        local LockpickNames = {UnlockPrompt = true, ThingToEnable = true, LockPrompt = true, SkullPrompt = true, FusesPrompt = true}
        local ShearsParents = {Chest_Vine = true, CuttableVines = true, Cellar = true}
        local ShearsNames = {SkullPrompt = true}
        local KeyParents = {Keyhole = true, LockedDoor = true}
        local KeyNames = {KeyPrompt = true}
        local CrowbarParents = {SealedCrate = true, Boarded = true}
        local CrowbarNames = {PryPrompt = true}

        local InfStore, InfSStore, InfKStore, InfCStore = {}, {}, {}, {}
        local attachConn, roomConn, lastCheck = nil, nil, 0

        if not Value then
            cleanupEnableReal()
            InfStore, InfSStore, InfKStore, InfCStore = {}, {}, {}, {}
            if attachConn then attachConn:Disconnect() attachConn = nil end
            if roomConn then roomConn:Disconnect() roomConn = nil end
            return
        end

        local function tryAttachAll()
            local char = player.Character
            if not char then return end

            local function attachIfHas(toolName, store)
                local hasTool = (char:FindFirstChild(toolName) or player.Backpack:FindFirstChild(toolName))
                if hasTool then
                    for _, prompt in ipairs(store) do
                        if prompt and prompt.Parent and not prompt:GetAttribute("HasFake") then
                            addFake(prompt, toolName)
                        end
                    end
                end
            end

            attachIfHas("Lockpick", InfStore)
            attachIfHas("Shears", InfSStore)
            attachIfHas("Key", InfKStore)
            attachIfHas("Crowbar", InfCStore)
        end

        local function rescanAll()
            InfStore = scanPrompts(LockpickParents, LockpickNames)
            InfSStore = scanPrompts(ShearsParents, ShearsNames)
            InfKStore = scanPrompts(KeyParents, KeyNames)
            InfCStore = scanPrompts(CrowbarParents, CrowbarNames)
            tryAttachAll()
        end

        rescanAll()

        roomConn = roomFolder.ChildAdded:Connect(rescanAll)

        attachConn = Run.Heartbeat:Connect(function(dt)
    if not Value then return end
    lastCheck = lastCheck + dt 
    if lastCheck < 0.2 then return end
    lastCheck = 0
    tryAttachAll()
end)


        local function hookChildChanges(container)
            container.ChildAdded:Connect(function(child)
                local name = child.Name:lower()
                if name:find("lockpick", 1, true) or name:find("skeleton", 1, true) then
                    InfStore = scanPrompts(LockpickParents, LockpickNames)
                    tryAttachAll()
                elseif name:find("shears", 1, true) then
                    InfSStore = scanPrompts(ShearsParents, ShearsNames)
                    tryAttachAll()
                elseif name:find("key", 1, true) then
                    InfKStore = scanPrompts(KeyParents, KeyNames)
                    tryAttachAll()
                elseif name:find("crowbar", 1, true) then
                    InfCStore = scanPrompts(CrowbarParents, CrowbarNames)
                    tryAttachAll()
                end
            end)
            container.ChildRemoved:Connect(function(child)
                local name = child.Name:lower()
                if name:find("lockpick", 1, true) or name:find("skeleton", 1, true) then
                    InfStore = scanPrompts(LockpickParents, LockpickNames)
                    tryAttachAll()
                elseif name:find("shears", 1, true) then
                    InfSStore = scanPrompts(ShearsParents, ShearsNames)
                    tryAttachAll()
                elseif name:find("key", 1, true) then
                    InfKStore = scanPrompts(KeyParents, KeyNames)
                    tryAttachAll()
                elseif name:find("crowbar", 1, true) then
                    InfCStore = scanPrompts(CrowbarParents, CrowbarNames)
                    tryAttachAll()
                end
            end)
        end

        player.CharacterAdded:Connect(function(char)
            hookChildChanges(char)
        end)
        hookChildChanges(player.Backpack)
    end
})

CheatStuff:AddDivider()


local doorReachLoop

CheatStuff:AddCheckbox("DoorReach", {
    Text = "Door Reach",
    Default = false,
    Disabled = false,
    Tooltip = "increases door reach opening",
    Callback = function(Value)
        if Value then
            local Rooms = workspace:FindFirstChild("CurrentRooms")
            if not Rooms then return end

            doorReachLoop = task.spawn(function()
                while Toggles.DoorReach and Toggles.DoorReach.Value do
                    for _, room in pairs(Rooms:GetChildren()) do
                        local door = room:FindFirstChild("Door")
                        if door and door:FindFirstChild("ClientOpen") then
                            door.ClientOpen:FireServer()
                        end
                    end
                    task.wait(0.5)
                end
            end)
        else
            doorReachLoop = nil
        end
    end
})
CheatStuff:AddCheckbox("AutoMinecartPush", {
	Text = "Auto Minecart Push",
	Default = false,
	Disabled = false,
	Tooltip = "Automatically interacts with Minecart push prompt when near",
	Callback = function(Value)
		local Players = game:GetService("Players")
		local RunService = game:GetService("RunService")
		local LocalPlayer = Players.LocalPlayer
		local Rooms = workspace:WaitForChild("CurrentRooms")

		if _G.AutoMinecartConn then _G.AutoMinecartConn:Disconnect() end
		if _G.AutoMinecartLoop then _G.AutoMinecartLoop:Disconnect() end
		_G.AutoMinecartConn, _G.AutoMinecartLoop = nil, nil

		if not Value then return end

		local function tryPush(model)
			local cart = model:FindFirstChild("Cart")
			local prompt = cart and cart:FindFirstChild("PushPrompt")
			local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			if not (prompt and root) then return end
			if (root.Position - prompt.Parent.Position).Magnitude <= (prompt.MaxActivationDistance or 10) then
				fireproximityprompt(prompt)
			end
		end

		_G.AutoMinecartConn = Rooms.DescendantAdded:Connect(function(obj)
			if obj.Name == "MinecartMoving" then
				task.defer(tryPush, obj)
			end
		end)

		local elapsed = 0
		_G.AutoMinecartLoop = RunService.Heartbeat:Connect(function(dt)
			elapsed = elapsed + dt  -- FIXED: Changed += to = + 
			if elapsed < 1 then return end
			elapsed = 0

			local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			if not root then return end

			for _, obj in ipairs(Rooms:GetChildren()) do
				if obj.Name == "MinecartMoving" then
					tryPush(obj)
				end
			end
		end)
	end
})




CheatStuff:AddCheckbox("InstantInteract", {
    Text = "Instant Interact",
    Default = false,
    Disabled = false,
    Tooltip = "removes the little waittimes of proximity prompts",
    Callback = function(Value)
        if getgenv().ProximityConnection then
            getgenv().ProximityConnection:Disconnect()
            getgenv().ProximityConnection = nil
        end
        local function modifyPrompt(prompt, instant)
            if not prompt:IsA("ProximityPrompt") then return end

            if instant then
                if not prompt:GetAttribute("OriginalHoldDuration") then
                    prompt:SetAttribute("OriginalHoldDuration", prompt.HoldDuration)
                    prompt:SetAttribute("OriginalLineOfSight", prompt.RequiresLineOfSight)
                end
                prompt.HoldDuration = 0
                prompt.RequiresLineOfSight = false
            else
                prompt.HoldDuration = prompt:GetAttribute("OriginalHoldDuration") or 1
                prompt.RequiresLineOfSight = prompt:GetAttribute("OriginalLineOfSight") or true
            end
        end
        local currentRooms = workspace:FindFirstChild("CurrentRooms")
        if currentRooms then
            for _, prompt in ipairs(currentRooms:GetDescendants()) do
                if prompt:IsA("ProximityPrompt") then
                    modifyPrompt(prompt, Value)
                end
            end
        end
        if Value and currentRooms then
            getgenv().ProximityConnection = currentRooms.DescendantAdded:Connect(function(descendant)
                if descendant:IsA("ProximityPrompt") then
                    modifyPrompt(descendant, true)
                end
            end)
        end
    end
})

CheatStuff:AddDivider()


CheatStuff:AddCheckbox("AutoInteract", {
    Text = "Auto Interact",
    Default = false,
    Risky = false,
    Disabled = false,
    Callback = function(Value)
        if Value then
            _G.IgnoredItems = _G.IgnoredItems or {}
            local RunService = game:GetService("RunService")
            local LocalPlayer = game.Players.LocalPlayer
            AutoInteractDistance = AutoInteractDistance or 10
            local AutoInteractConnection
            local CachedInteractables = {}
            local PromptSeen = {}
            local InteractableModels = {
                ["AlarmClock"] = true, ["GlitchCub"] = true, ["Aloe"] = true,
                ["BandagePack"] = true, ["Battery"] = true, ["TimerLever"] = true,
                ["OuterPart"] = true, ["BatteryPack"] = true, ["Candle"] = true,
                ["LiveBreakerPolePickup"] = true, ["Compass"] = true, ["Crucifix"] = true,
                ["ElectricalRoomKey"] = true, ["Flashlight"] = true, ["Glowstick"] = true,
                ["HolyHandGrenade"] = true, ["Lantern"] = true, ["LaserPointer"] = true,
                ["Lighter"] = true, ["Lockpick"] = true, ["LotusFlower"] = true,
                ["LotusPetalPickup"] = true, ["Multitool"] = true, ["NVCS3000"] = true,
                ["OutdoorsKey"] = true, ["Shears"] = true, ["SkeletonKey"] = true,
                ["Smoothie"] = true, ["SolutionPaper"] = true, ["Spotlight"] = true,
                ["StarlightVial"] = true, ["StarlightJug"] = true, ["StarlightBottle"] = true,
                ["Vitamins"] = true,
            }

            local function PickRootPart(obj, prompt)
                if prompt and prompt.Parent and prompt.Parent:IsA("BasePart") then
                    return prompt.Parent
                end
                if obj:IsA("Model") then
                    if obj.PrimaryPart and obj.PrimaryPart:IsA("BasePart") then
                        return obj.PrimaryPart
                    end
                    local common = obj:FindFirstChild("Main", true) or obj:FindFirstChild("Handle", true) or obj:FindFirstChild("Door", true)
                    if common and common:IsA("BasePart") then
                        return common
                    end
                end
                return obj:FindFirstChildWhichIsA("BasePart", true)
            end

            local function AddPromptsFromObject(obj, category)
                for _, desc in ipairs(obj:GetDescendants()) do
                    if desc:IsA("ProximityPrompt") and not PromptSeen[desc] then
                        local root = PickRootPart(obj, desc)
                        if root then
                            PromptSeen[desc] = true
                            table.insert(CachedInteractables, {prompt = desc, part = root, last = 0, category = category})
                        end
                    end
                end
            end

            local function CollectTargets(folder)
                for _, v in ipairs(folder:GetChildren()) do
                    if v:IsA("Model") or v:IsA("Folder") then
                        local collect = false
                        local category = nil
                        if v.Name == "GlitchCub" then
                            category = "glitchcube"
                            collect = true
                        elseif InteractableModels[v.Name] then
                            category = "item"
                            collect = true
                        elseif v.Name == "DrawerContainer"
                        or v.Name == "RoomsLootItem"
                        or v.Name == "Locker_Small"
                        or v.Name == "Toolbox"
                        or v.Name == "ChestBox"
                        or v.Name == "Toolshed_Small"
                        or v.Name == "CrucifixOnTheWall" then
                            category = "container"
                            collect = true
                        end
                        if collect then
                            AddPromptsFromObject(v, category)
                        end
                        CollectTargets(v)
                    end
                end
            end

            local function RefreshTargets()
                CachedInteractables = {}
                PromptSeen = {}
                local CurrentRoom = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]
                if not CurrentRoom then return end
                CollectTargets(CurrentRoom)
            end

            local lastCheck = 0
            local interval = 0.2
            local function AutoInteractStep(dt)
                lastCheck = lastCheck + dt 
                if lastCheck < interval then return end
                lastCheck = 0
                if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Collision") then return end
                local charPos = LocalPlayer.Character.Collision.Position
                local now = tick()
                for i = #CachedInteractables, 1, -1 do
                    local entry = CachedInteractables[i]
                    local prompt, part, category = entry.prompt, entry.part, entry.category
                    if not prompt or not prompt.Parent or not part or not part:IsDescendantOf(workspace) then
                        table.remove(CachedInteractables, i)
                    else
                        local shouldIgnore = false
                        if category == "item" and _G.IgnoredItems["Items"] then
                            shouldIgnore = true
                        elseif category == "container" and _G.IgnoredItems["Containers"] then
                            shouldIgnore = true
                        elseif category == "glitchcube" and _G.IgnoredItems["Glitch Cube"] then
                            shouldIgnore = true
                        end
                        local dist = (part.Position - charPos).Magnitude
                        if dist <= AutoInteractDistance and now - (entry.last or 0) >= 0.35 and not shouldIgnore then
                            entry.last = now
                            task.spawn(function() 
                                pcall(function() 
                                    fireproximityprompt(prompt) 
                                end) 
                            end)
                        end
                    end
                end
            end

            RefreshTargets()
            AutoInteractConnection = RunService.Heartbeat:Connect(AutoInteractStep)

            local attributeConn
            local roomDescConn
            attributeConn = LocalPlayer:GetAttributeChangedSignal("CurrentRoom"):Connect(function()
                RefreshTargets()
                if roomDescConn then 
                    roomDescConn:Disconnect() 
                    roomDescConn = nil 
                end
                local cr = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]
                if cr then
                    roomDescConn = cr.DescendantAdded:Connect(function() 
                        task.defer(RefreshTargets) 
                    end)
                end
            end)

            local cr = workspace.CurrentRooms[LocalPlayer:GetAttribute("CurrentRoom")]
            if cr then
                roomDescConn = cr.DescendantAdded:Connect(function() 
                    task.defer(RefreshTargets) 
                end)
            end

            _G.StopAutoInteract = function()
                if AutoInteractConnection then 
                    AutoInteractConnection:Disconnect() 
                    AutoInteractConnection = nil 
                end
                if attributeConn then 
                    attributeConn:Disconnect() 
                    attributeConn = nil 
                end
                if roomDescConn then 
                    roomDescConn:Disconnect() 
                    roomDescConn = nil 
                end
                CachedInteractables, PromptSeen = {}, {}
            end
        else
            if _G.StopAutoInteract then
                _G.StopAutoInteract()
                _G.StopAutoInteract = nil
            end
        end
    end
})

local ignoreValues = { "Items", "Containers", "Glitch Cube" }

CheatStuff:AddDropdown("IgnoreList", {
    Text = "Ignore List",
    Default = {},
    Values = ignoreValues,
    Multi = true,
    Callback = function(Value)
        _G.IgnoredItems = {}
        for _, item in ipairs(Value) do
            _G.IgnoredItems[item] = true
        end
    end
})


CheatStuff:AddDivider()


CheatStuff:AddCheckbox("PromptClip", {
	Text = "Prompt Clip",
	Default = false,
	Callback = function(Value)
		for _, obj in ipairs(workspace.CurrentRooms:GetDescendants()) do
			if obj:IsA("ProximityPrompt") then
				obj.RequiresLineOfSight = not Value
			end
		end
	end
})


local originalRanges = {}
local rangeConnections = {}

local function updateProximityPromptRanges(multiplier)
	for _, prompt in ipairs(workspace:GetDescendants()) do
		if prompt:IsA("ProximityPrompt") then
			if not originalRanges[prompt] then
				originalRanges[prompt] = prompt.MaxActivationDistance
			end
			prompt.MaxActivationDistance = originalRanges[prompt] * multiplier
		end
	end
end

local function setupRangeConnections(multiplier)
	for _, prompt in ipairs(workspace:GetDescendants()) do
		if prompt:IsA("ProximityPrompt") then
			local conn = prompt.AncestryChanged:Connect(function()
				if prompt.Parent then
					if not originalRanges[prompt] then
						originalRanges[prompt] = prompt.MaxActivationDistance
					end
					prompt.MaxActivationDistance = originalRanges[prompt] * multiplier
				end
			end)
			table.insert(rangeConnections, conn)
		end
	end
end

CheatStuff:AddSlider("RangeBoost", {
	Text = "Interaction Boost",
	Default = 1,
	Min = 1,
	Max = 2,
	Rounding = 1,
	Compact = true,
	Callback = function(multiplier)
		if multiplier == 1 then
			for prompt, originalRange in pairs(originalRanges) do
				if prompt and prompt.Parent then
					prompt.MaxActivationDistance = originalRange
				end
			end
			for _, connection in pairs(rangeConnections) do
				connection:Disconnect()
			end
			rangeConnections = {}
		else
			updateProximityPromptRanges(multiplier)
			setupRangeConnections(multiplier)
		end
	end
})





















local RandomStuff = Tabs.Misc:AddLeftGroupbox("The Hotel")


RandomStuff:AddCheckbox('AntiJam',{
     Text = "Anti Jam",
     Default = false,
     Disabled = false,
Callback = function(Value)

		if Modifiers and not Modifiers:FindFirstChild("Jammin") then return end
		local mainTrack = game["SoundService"]:FindFirstChild("Main")
		if mainTrack then
			local jamming = mainTrack:FindFirstChild("Jamming")
			if jamming then
				jamming.Enabled = not Value
			end
		end

		local mainUI = LocalPlayer:FindFirstChild("PlayerGui")
			and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
		if mainUI then
			local healthGui = mainUI:FindFirstChild("Initiator")
				and mainUI.Initiator:FindFirstChild("Main_Game")
				and mainUI.Initiator.Main_Game:FindFirstChild("Health")
			if healthGui then
				local jamSound = healthGui:FindFirstChild("Jam")
				if jamSound then
					jamSound.Playing = not Value
				end
			end
		end
	end
})

local clones = {}
local bridgeConns = {}

local function makeBarrier(barrier)
	if barrier.Parent:FindFirstChild("AntiBridge") then return end
	local clone = barrier:Clone()
	clone.Name = "AntiBridge"
	clone.Size = Vector3.new(barrier.Size.X, barrier.Size.Y, 30)
	clone.Color = Color3.new(0,0,0.5)
	clone.CFrame = barrier.CFrame * CFrame.new(0, 0, -5)
	clone.Transparency = 0
	clone.Anchored = true
	clone.CanCollide = true
	clone.CanTouch = true
	clone.Parent = barrier.Parent
	table.insert(clones, clone)
end

local function processBridge(bridge)
	if bridge:FindFirstChild("AntiBridge") then return end
	for _, part in ipairs(bridge:GetChildren()) do
		if part.Name == "PlayerBarrier" and part.Size.Y == 2.75 and (part.Rotation.X % 180) == 0 then
			makeBarrier(part)
		end
	end
	local conn = bridge.ChildAdded:Connect(function(c)
		if c.Name == "PlayerBarrier" then
			makeBarrier(c)
		end
	end)
	table.insert(bridgeConns, conn)
end

local clones = {}
local bridgeConns = {}

local function makeBarrier(barrier)
	if barrier.Parent:FindFirstChild("AntiBridge") then return end
	local clone = barrier:Clone()
	clone.Name = "AntiBridge"
	clone.Size = Vector3.new(barrier.Size.X, barrier.Size.Y, 30)
	clone.Color = Color3.new(0,0,0.5)
	clone.CFrame = barrier.CFrame * CFrame.new(0, 0, -5)
	clone.Transparency = 0
	clone.Anchored = true
	clone.CanCollide = true
	clone.CanTouch = true
	clone.Parent = barrier.Parent
	table.insert(clones, clone)
end

local function processBridge(bridge)
	if bridge:FindFirstChild("AntiBridge") then return end
	for _, part in ipairs(bridge:GetChildren()) do
		if part.Name == "PlayerBarrier" and part.Size.Y == 2.75 and (part.Rotation.X % 180) == 0 then
			makeBarrier(part)
		end
	end
	local conn = bridge.ChildAdded:Connect(function(c)
		if c.Name == "PlayerBarrier" then
			makeBarrier(c)
		end
	end)
	table.insert(bridgeConns, conn)
end




RandomStuff:AddDivider()

RandomStuff:AddButton({
    Text = "Death Farm V2",
    Disabled = false,
    Func = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Msdoors/Msdoors.gg/refs/heads/main/Scripts/Msdoors/internal/replicatesignal(LocalPlayer.init_msdoors).luau"))()
    end
})

local SeekGroup = Tabs.Misc:AddLeftGroupbox("Seek Stuff")
SeekGroup:AddCheckbox("AntiFlood", {
	Text = "No Seek Flood Damage",
	Default = false,
	Disabled = false,
	Callback = function(Value)
		if not Value then return end

		local RunService = game:GetService("RunService")
		local found = false
		local elapsed = 0

		local conn
		conn = RunService.Heartbeat:Connect(function(dt)
			if not Value then
				conn:Disconnect()
				return
			end

			if found then
				conn:Disconnect()
				return
			end

			elapsed = elapsed + dt  
			if elapsed < 0.5 then return end
			elapsed = 0

			for _, obj in ipairs(workspace:GetChildren()) do
				if obj.Name == "SeekFloodline" and obj:IsA("BasePart") then
					obj.CanCollide = true
					found = true
					Library:Notify("It's safe to walk on the seek ocean thingy", 3)
					conn:Disconnect()
					break
				end
			end
		end)
	end
})

SeekGroup:AddCheckbox("SeekBridgeCover", {
	Text = "Seek Bridge Cover",
	Default = false,
	Disabled = false,
	Callback = function(Value)
		if Value then
			local RunService = game:GetService("RunService")
			local Players = game:GetService("Players")
			local Workspace = game:GetService("Workspace")

			local MODEL_NAME = "Bridge"
			local SCAN_INTERVAL = 1
			local DEFAULTS = {
				HeightOffset = 30,
				Thickness = 1,
				PaddingX = -5,
				PaddingZ = -5,
				Color = Color3.fromRGB(36, 16, 0)
			}

			local bridges = {}

			local function getBridgeSettings(bridge)
				return {
					HeightOffset = bridge:GetAttribute("HeightOffset") or DEFAULTS.HeightOffset,
					Thickness = bridge:GetAttribute("Thickness") or DEFAULTS.Thickness,
					PaddingX = bridge:GetAttribute("PaddingX") or DEFAULTS.PaddingX,
					PaddingZ = bridge:GetAttribute("PaddingZ") or DEFAULTS.PaddingZ,
					Color = bridge:GetAttribute("Color") or DEFAULTS.Color
				}
			end

			local rootNames = {HumanoidRootPart=true, Torso=true, UpperTorso=true, LowerTorso=true}
			local function findRootPart(character)
				for name in pairs(rootNames) do
					local p = character:FindFirstChild(name)
					if p then return p end
				end
				return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChildWhichIsA("BasePart")
			end

			local function createPlatform(bridge)
				if bridges[bridge] then
					if bridges[bridge].platform and bridges[bridge].platform.Parent then
						bridges[bridge].platform:Destroy()
					end
					bridges[bridge] = nil
				end

				local settings = getBridgeSettings(bridge)
				local modelCFrame, modelSize = bridge:GetBoundingBox()

				local part = Instance.new("Part")
				part.Name = "BridgePlatform"
				part.Anchored = true
				part.CanCollide = false
				part.Material = Enum.Material.Wood
				part.Color = settings.Color
				part.Size = Vector3.new(math.max(0.1, modelSize.X - settings.PaddingX * 2), settings.Thickness, math.max(0.1, modelSize.Z - settings.PaddingZ * 2))
				part.CFrame = modelCFrame * CFrame.new(0, -modelSize.Y / 2 + settings.HeightOffset, 0)
				part.Parent = bridge

				bridges[bridge] = { platform = part, settings = settings, touchingPlayers = {}, debounces = {} }

				local function snapPlayerToPlatform(player, character)
					local record = bridges[bridge]
					if not record or not record.platform or not record.platform.Parent then return end
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					local root = findRootPart(character)
					if not humanoid or not root then return end
					local now = tick()
					if record.debounces[player] and now - record.debounces[player] < 0.12 then return end
					record.debounces[player] = now
					local platformTop = record.platform.Position.Y + record.platform.Size.Y/2
					local vy = 0
					if root:IsA("BasePart") and root:FindFirstChildWhichIsA("Vector3Value") == nil then
						local ok, vel = pcall(function() return root.Velocity end)
						if ok and vel then vy = vel.Y end
					end
					if (vy <= 0) and root.Position.Y < platformTop + 3 then
						local hip = humanoid.HipHeight or 2
						local targetY = platformTop + hip + 0.5
						root.CFrame = CFrame.new(root.Position.X, targetY, root.Position.Z) * CFrame.Angles(root.CFrame:ToEulerAnglesXYZ())
					end
				end

				local function onTouched(hit)
					local char = hit.Parent
					local player = Players:GetPlayerFromCharacter(char)
					if not player then return end
					bridges[bridge].touchingPlayers[player] = true
					snapPlayerToPlatform(player, char)
				end

				local function onTouchEnded(hit)
					local char = hit.Parent
					local player = Players:GetPlayerFromCharacter(char)
					if not player then return end
					bridges[bridge].touchingPlayers[player] = nil
					bridges[bridge].debounces[player] = nil
				end

				local tconn = part.Touched:Connect(onTouched)
				local teconn = part.TouchEnded:Connect(onTouchEnded)
				bridges[bridge].connections = { tconn, teconn }
			end

			local function cleanupPlatform(bridge)
				if bridges[bridge] then
					local record = bridges[bridge]
					if record.connections then
						for _,c in ipairs(record.connections) do
							if c and c.Connected then pcall(function() c:Disconnect() end) end
						end
					end
					if record.platform and record.platform.Parent then
						record.platform:Destroy()
					end
					bridges[bridge] = nil
				end
			end

			local function updateBridges()
				local found = {}
				for _, desc in ipairs(Workspace:GetDescendants()) do
					if desc:IsA("Model") and desc.Name == MODEL_NAME then
						found[desc] = true
						if not bridges[desc] then
							createPlatform(desc)
						end
					end
				end
				for b in pairs(bridges) do
					if not found[b] or not b.Parent then
						cleanupPlatform(b)
					end
				end
			end

			local hbConn = RunService.Heartbeat:Connect(function()
				for bridge, data in pairs(bridges) do
					if bridge and bridge.Parent and data.platform and data.platform.Parent then
						local modelCFrame, modelSize = bridge:GetBoundingBox()
						local s = data.settings
						data.platform.CFrame = modelCFrame * CFrame.new(0, -modelSize.Y / 2 + s.HeightOffset, 0)
					end
				end
			end)

			local scanning = true
			task.spawn(function()
				while scanning do
					updateBridges()
					task.wait(SCAN_INTERVAL)
				end
			end)
			_G.SeekBridgeCover = {
				Bridges = bridges,
				HeartbeatConn = hbConn,
				Stop = function()
					scanning = false
					if hbConn and hbConn.Connected then
						hbConn:Disconnect()
					end
					for b in pairs(bridges) do
						if bridges[b] then
							if bridges[b].platform and bridges[b].platform.Parent then
								bridges[b].platform:Destroy()
							end
						end
					end
					table.clear(bridges)
				end
			}
		else
			if _G.SeekBridgeCover then
				_G.SeekBridgeCover.Stop()
				_G.SeekBridgeCover = nil
			end
		end
	end
})

SeekGroup:AddCheckbox("SeekPathESP", {
    Text = "Seek Path",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        Script.Temp = Script.Temp or {}
        Script.Temp.SeekPathConns = Script.Temp.SeekPathConns or {}

        local pathFolder
        local function ensureFolder()
            if not pathFolder or not pathFolder.Parent then
                pathFolder = Instance.new("Folder")
                pathFolder.Name = "Path Node"
                pathFolder.Parent = workspace
            end
            return pathFolder
        end

        local function clearFolder()
            if pathFolder then
                for _, v in pairs(pathFolder:GetChildren()) do
                    v:Destroy()
                end
            end
        end

        local function createSphere(pos)
            local part = Instance.new("Part")
            part.Size = Vector3.new(1, 1, 1)
            part.Shape = Enum.PartType.Ball
            part.Material = Enum.Material.Neon
            part.Color = Color3.fromRGB(0, 255, 0) 
            part.Anchored = true
            part.CanCollide = false
            part.Transparency = 0.3
            part.CFrame = CFrame.new(pos)
            part.Parent = ensureFolder()

            task.spawn(function()
                local player = game.Players.LocalPlayer
                if not player or not player.Character then return end
                local root = player.Character:WaitForChild("HumanoidRootPart", 5)
                if not root then return end

                while part.Parent do
                    if (root.Position - part.Position).Magnitude < 5 then 
                        part:Destroy()
                        break
                    end
                    task.wait(0.1)
                end
            end)

            return part
        end

        local function redraw()
            clearFolder()
            local lights = Script.Temp.Lights or {}
            if #lights == 0 then return end

            local positions = {}
            for _, light in ipairs(lights) do
                if light and light.Parent then
                    table.insert(positions, light.Position)
                end
            end
            if #positions == 0 then return end

            table.sort(positions, function(a, b)
                return a.X + a.Y + a.Z < b.X + b.Y + b.Z
            end)

            for _, pos in ipairs(positions) do
                createSphere(pos)
            end
        end

        if Value then
            ensureFolder()
            Script.Temp.Lights = {}

            local function addLight(light)
                if not light or not light.Parent then return end
                table.insert(Script.Temp.Lights, light)
                redraw()
            end

            for _, v in ipairs(workspace:GetDescendants()) do
                if v.Name == "SeekGuidingLight" then
                    pcall(addLight, v)
                end
            end

            Script.Temp.SeekPathAddedConn = workspace.DescendantAdded:Connect(function(obj)
                if not Value then return end
                if obj.Name == "SeekGuidingLight" then
                    pcall(addLight, obj)
                end
            end)

            Script.Temp.SeekPathRemovedConn = workspace.DescendantRemoving:Connect(function(obj)
                if not Value then return end
                if obj.Name == "SeekGuidingLight" then
                    for i, l in ipairs(Script.Temp.Lights) do
                        if l == obj then
                            table.remove(Script.Temp.Lights, i)
                            break
                        end
                    end
                    redraw()
                end
            end)
        else
            if Script.Temp.SeekPathAddedConn then
                Script.Temp.SeekPathAddedConn:Disconnect()
                Script.Temp.SeekPathAddedConn = nil
            end
            if Script.Temp.SeekPathRemovedConn then
                Script.Temp.SeekPathRemovedConn:Disconnect()
                Script.Temp.SeekPathRemovedConn = nil
            end
            Script.Temp.Lights = nil
            Script.Temp.SeekPathConns = {}
            clearFolder()
        end
    end
})


local BattleGroup = Tabs.Misc:AddRightGroupbox("Battlemode")



BattleGroup:AddCheckbox("AutoPickupThrowables", {
	Text = "Auto Pickup Throwables",
	Default = false,
	Disabled = false,
	Callback = function(Value)
		local targetProps = {"WoodenCrate","OilBarrel","GarbageBag","Trashcan","CardboardBox_Normal","Hat_Stand","CardboardBox_Wide","Office_Chair"}
		local running = true
		if Value then
			task.spawn(function()
				while running and Value do
					local bigProps = workspace:FindFirstChild("BigProps")
					if bigProps then
						for _,name in ipairs(targetProps) do
							local prop = bigProps:FindFirstChild(name)
							if prop then
								for _,d in ipairs(prop:GetDescendants()) do
									if d:IsA("ProximityPrompt") then
										d.MaxActivationDistance = 20
										if d.Enabled then
											pcall(fireproximityprompt, d)
										end
									end
								end
							end
						end
					end
					task.wait(0.5)
				end
			end)
		else
			running = false
		end
	end
})


BattleGroup:AddCheckbox("Auto Break Door", {
	Text = "Auto Break Door",
	Default = false,
	Disabled = false,
	Callback = function(Value)
		local connections = {}
		local running = false
		local targetNames = {"DoorPieceBottom","DoorPieceTop"}
		local function safeDisconnect()
			for _,c in ipairs(connections) do
				if c and c.Disconnect then
					pcall(function() c:Disconnect() end)
				elseif c and c.disconnect then
					pcall(function() c:disconnect() end)
				end
			end
			connections = {}
		end
		local function handlePrompt(p)
			pcall(function() p.MaxActivationDistance = 40 end)
			if p.Enabled then pcall(fireproximityprompt, p) end
		end
		local function processModel(m)
			for _,n in ipairs(targetNames) do
				local part = m:FindFirstChild(n, true)
				if part then
					for _,d in ipairs(part:GetDescendants()) do
						if d:IsA("ProximityPrompt") then
							pcall(handlePrompt, d)
						end
					end
					local con = part.DescendantAdded:Connect(function(desc)
						if desc:IsA("ProximityPrompt") then
							pcall(function() task.defer(handlePrompt, desc) end)
						end
					end)
					table.insert(connections, con)
				end
			end
		end
		local function scanAll()
			local cr = workspace:FindFirstChild("CurrentRooms")
			if not cr then return end
			for _,room in ipairs(cr:GetDescendants()) do
				if room:IsA("Model") or room:IsA("Folder") then
					processModel(room)
				end
			end
		end
		if Value then
			running = true
			safeDisconnect()
			task.spawn(function()
				scanAll()
				local cr = workspace:FindFirstChild("CurrentRooms")
				if cr then
					local con = cr.DescendantAdded:Connect(function(d)
						if not running then return end
						local model = d
						while model and not (model:IsA("Model") or model:IsA("Folder")) do
							model = model.Parent
						end
						if model then
							task.defer(processModel, model)
						end
					end)
					table.insert(connections, con)
				end
				while running and Value do
					scanAll()
					task.wait(0.8)
				end
			end)
		else
			running = false
			safeDisconnect()
		end
	end
})

BattleGroup:AddCheckbox("Auto Pickup", {
	Text = "Auto Pickup",
	Default = false,
	Disabled = false,
	Callback = function(Value)
		local connections = {}
		local running = false
		local function safeDisconnect()
			for _,c in ipairs(connections) do
				if c and c.Disconnect then
					pcall(function() c:Disconnect() end)
				elseif c and c.disconnect then
					pcall(function() c:disconnect() end)
				end
			end
			connections = {}
		end
		local function handlePrompt(p)
			pcall(function() p.MaxActivationDistance = 40 end)
			if p.Enabled then pcall(fireproximityprompt, p) end
		end
		local function processDrop(d)
			for _,desc in ipairs(d:GetDescendants()) do
				if desc:IsA("ProximityPrompt") then
					pcall(handlePrompt, desc)
				end
			end
			local con = d.DescendantAdded:Connect(function(desc)
				if desc:IsA("ProximityPrompt") then
					pcall(function() task.defer(handlePrompt, desc) end)
				end
			end)
			table.insert(connections, con)
		end
		local function scanDrops()
			local drops = workspace:FindFirstChild("Drops")
			if not drops then return end
			for _,child in ipairs(drops:GetChildren()) do
				if child:IsA("Model") or child:IsA("Folder") then
					processDrop(child)
				end
			end
		end
		if Value then
			running = true
			safeDisconnect()
			task.spawn(function()
				scanDrops()
				local drops = workspace:FindFirstChild("Drops")
				if drops then
					local con = drops.ChildAdded:Connect(function(c)
						if not running then return end
						if c:IsA("Model") or c:IsA("Folder") then
							task.defer(processDrop, c)
						end
					end)
					table.insert(connections, con)
				end
				while running and Value do
					scanDrops()
					task.wait(0.8)
				end
			end)
		else
			running = false
			safeDisconnect()
		end
	end
})




BattleGroup:AddCheckbox("Auto Fire", {
    Text = "Auto Fire",
    Default = false,
    Disabled = false,
    Callback = function(Value)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local LocalPlayer = Players.LocalPlayer
        local Camera = workspace.CurrentCamera
        local RAY_DISTANCE = 50
        local con = nil
        local triggered = false

        local function safeMouse1Press() pcall(mouse1press) end
        local function safeMouse1Release() pcall(mouse1release) end

        local function isTargetVisible(targetChar, targetPos)
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Exclude
            rayParams.FilterDescendantsInstances = { LocalPlayer.Character, targetChar }

            local origin = Camera.CFrame.Position
            local direction = targetPos - origin
            local result = workspace:Raycast(origin, direction, rayParams)
            return not result
        end

        local function update()
            if not LocalPlayer.Character or not Camera then
                if triggered then safeMouse1Release(); triggered = false end
                return
            end

            local myChar = LocalPlayer.Character
            local myHead = myChar:FindFirstChild("Head")
            if not myHead then return end

            local lookVector = Camera.CFrame.LookVector
            local origin = Camera.CFrame.Position
            local bestTarget = nil
            local bestDot = 0.995

            for _, plr in pairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                    local targetChar = plr.Character
                    local targetPos = targetChar.HumanoidRootPart.Position
                    local dirToTarget = (targetPos - origin).Unit
                    local dot = lookVector:Dot(dirToTarget)

                    if dot > bestDot then
                        local dist = (targetPos - origin).Magnitude
                        if dist < RAY_DISTANCE and isTargetVisible(targetChar, targetPos) then
                            bestDot = dot
                            bestTarget = plr
                        end
                    end
                end
            end

            if bestTarget then
                if not triggered then
                    print("Firing at", bestTarget.Name)
                    safeMouse1Press()
                    triggered = true
                end
            else
                if triggered then
                    safeMouse1Release()
                    triggered = false
                end
            end
        end

        if Value then
            if con and con.Connected then con:Disconnect() end
            con = RunService.RenderStepped:Connect(function()
                pcall(update)
            end)
        else
            if con then con:Disconnect(); con = nil end
            if triggered then safeMouse1Release(); triggered = false end
        end
    end
})



local RoomsGroup = Tabs.Misc:AddRightGroupbox("The Rooms")

RoomsGroup:AddCheckbox("AutoRooms", {
    Text = "Auto Rooms",
    Default = false,
    Disabled = false,
    Callback = function(enabled)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local PathfindingService = game:GetService("PathfindingService")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Workspace = game:GetService("Workspace")

        local player = Players.LocalPlayer
        local rooms = Workspace:WaitForChild("CurrentRooms")
        local gameData = ReplicatedStorage:WaitForChild("GameData")
        local floor = gameData:WaitForChild("Floor")
        local active = false
        local runner
        local clone

        local function stop()
            active = false
            if runner then
                runner:Disconnect()
                runner = nil
            end
            if clone and clone.Parent then
                clone:Destroy()
            end
            player:SetAttribute("AutoRoomsActive", false)
        end

        if not enabled then
            stop()
            return
        end

        player:SetAttribute("AutoRoomsActive", true)
        active = true

        if player.Character and player.Character:FindFirstChild("CollisionPart") then
            clone = player.Character.CollisionPart:Clone()
            clone.Name = "_AutoRoomsCollision"
            clone.Massless = true
            clone.Anchored = false
            clone.CanCollide = false
            clone.CanQuery = false
            clone.CustomPhysicalProperties = PhysicalProperties.new(0.01, 0.7, 0, 1, 1)
            clone.Parent = player.Character
        end

        local function findClosestLocker()
            local best, bestDist = nil, math.huge
            for _, obj in ipairs(rooms:GetDescendants()) do
                if obj.Name == "Rooms_Locker" or obj.Name == "Rooms_Locker_Fridge" then
                    if obj.PrimaryPart then
                        local dist = (player.Character.HumanoidRootPart.Position - obj.PrimaryPart.Position).Magnitude
                        if dist < bestDist then
                            best = obj
                            bestDist = dist
                        end
                    end
                end
            end
            return best
        end

        local function walkTo(target)
            local char = player.Character
            if not (char and char:FindFirstChild("HumanoidRootPart")) then return end

            local path = PathfindingService:CreatePath({
                AgentRadius = 2,
                AgentHeight = 1,
                AgentCanJump = false,
                WaypointSpacing = 5
            })

            path:ComputeAsync(char.HumanoidRootPart.Position, target.Position)

            if path.Status == Enum.PathStatus.Success then
                for _, waypoint in ipairs(path:GetWaypoints()) do
                    if not active then return end
                    char:FindFirstChildOfClass("Humanoid"):MoveTo(waypoint.Position)
                    char.Humanoid.MoveToFinished:Wait()
                end
            end
        end

        runner = RunService.Heartbeat:Connect(function()
            if not active then return end
            if floor.Value ~= "Rooms" then return stop() end
            if gameData.LatestRoom.Value >= 1000 then return stop() end

            local entity = Workspace:FindFirstChild("A60")
                or Workspace:FindFirstChild("A120")
                or Workspace:FindFirstChild("GlitchRush")
                or Workspace:FindFirstChild("GlitchAmbush")

            if entity and entity.PrimaryPart and entity.PrimaryPart.Position.Y > -6 then
                local locker = findClosestLocker()
                if locker and locker.PrimaryPart then
                    local hide = locker:FindFirstChild("HidePoint")
                    if not hide then
                        hide = Instance.new("Part")
                        hide.Name = "HidePoint"
                        hide.Anchored = true
                        hide.Transparency = 1
                        hide.CanCollide = false
                        hide.Position = locker.PrimaryPart.Position + locker.PrimaryPart.CFrame.LookVector * 7
                        hide.Parent = locker
                    end
                    walkTo(hide)
                    task.wait(0.1)
                    local prompt = locker:FindFirstChildOfClass("ProximityPrompt")
                    if prompt then
                        if fireproximityprompt then
                            fireproximityprompt(prompt)
                        else
                            prompt:InputHoldBegin()
                            prompt:InputHoldEnd()
                        end
                    end
                end
            else
                local currentRoom = gameData.LatestRoom.Value
                local door = rooms[currentRoom] and rooms[currentRoom]:FindFirstChild("Door", true)
                if door and door:FindFirstChild("Door") then
                    walkTo(door.Door)
                end
            end
        end)
    end
})


local A90Hook

RoomsGroup:AddCheckbox("AvoidA90", {
    Text = "Avoid A-90",
    Default = false,
    Disabled = false,
    Tooltip = "Removes A90",
    Callback = function(ad)
        local modules = LocalPlayer.PlayerGui:FindFirstChild("MainUI")
            and LocalPlayer.PlayerGui.MainUI:FindFirstChild("Initiator")
            and LocalPlayer.PlayerGui.MainUI.Initiator:FindFirstChild("Main_Game")
            and LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game:FindFirstChild("RemoteListener")
            and LocalPlayer.PlayerGui.MainUI.Initiator.Main_Game.RemoteListener:FindFirstChild("Modules")

        local c3 = modules and (modules:FindFirstChild("A90") or modules:FindFirstChild("_A90"))
        if c3 then
            c3.Name = ad and "_A90" or "A90"
        end

        local remote = game:GetService("ReplicatedStorage"):FindFirstChild("RemotesFolder")
            and game:GetService("ReplicatedStorage").RemotesFolder:FindFirstChild("A90")
            or game:GetService("ReplicatedStorage").RemotesFolder:FindFirstChild("_A90")
        if remote then
            remote.Name = ad and "_A90" or "A90"
        end
    end
})

local AprilFools = Tabs.Misc:AddRightGroupbox("April Fools 2023")

local currentRooms = workspace:WaitForChild("CurrentRooms")

local antiBananaConn
AprilFools:AddCheckbox("AntiBanana", {
    Text = "Anti Banana",
    Default = false,
    Callback = function(Value)
        if antiBananaConn then
            antiBananaConn:Disconnect()
            antiBananaConn = nil
        end

        for _, v in pairs(currentRooms:GetDescendants()) do
            if v.Name == "BananaPeel" and v:IsA("BasePart") then
                v.CanTouch = not Value
            end
        end

        if Value then
            antiBananaConn = currentRooms.DescendantAdded:Connect(function(v)
                if v.Name == "BananaPeel" and v:IsA("BasePart") then
                    v.CanTouch = false
                end
            end)
        end
    end
})

local antiJeffConn
AprilFools:AddCheckbox("AntiJeff", {
    Text = "Anti Jeff",
    Default = false,
    Callback = function(Value)
        if antiJeffConn then
            antiJeffConn:Disconnect()
            antiJeffConn = nil
        end

        for _, model in pairs(currentRooms:GetDescendants()) do
            if model.Name == "JeffTheKiller" and model:IsA("Model") then
                for _, part in ipairs(model:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.CanTouch = not Value
                    end
                end
            end
        end

        if Value then
            antiJeffConn = currentRooms.DescendantAdded:Connect(function(v)
                if v.Name == "JeffTheKiller" and v:IsA("Model") then
                    for _, part in ipairs(v:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.CanTouch = false
                        end
                    end
                end
            end)
        end
    end
})


local CreditsTab = Window:AddTab("Credits", "database")

local CreditsGroupbox = CreditsTab:AddLeftGroupbox("Ostium Team")
CreditsGroupbox:AddLabel('<font color="rgb(0, 204, 255)"><b>Owner & Lead Developer</b></font>')
CreditsGroupbox:AddLabel('Velocity', true)
CreditsGroupbox:AddLabel('<font color="rgb(0, 204, 255)"><b>Developer</b></font>')
CreditsGroupbox:AddLabel('thehuntersolo1', true)
CreditsGroupbox:AddDivider()
CreditsGroupbox:AddLabel('<font color="rgb(0, 204, 255)"><b>Death Farm</b></font>')
CreditsGroupbox:AddLabel('By Rhyan57', true)
CreditsGroupbox:AddDivider()
CreditsGroupbox:AddLabel('<font color="rgb(0, 204, 255)"><b>Special Thanks</b></font>')
CreditsGroupbox:AddLabel('koekis2, lekkie2', true)
CreditsGroupbox:AddDivider()
CreditsGroupbox:AddLabel('<font color="rgb(0, 204, 255)"><b>Community Contributors</b></font>')
CreditsGroupbox:AddLabel('Jack', true)
CreditsGroupbox:AddDivider()
CreditsGroupbox:AddLabel('<font color="rgb(0, 204, 255)"><b>ESP Library</b></font>')
CreditsGroupbox:AddLabel('bocaj11104 esp library', true)
CreditsGroupbox:AddDivider()
CreditsGroupbox:AddLabel('<font color="rgb(0, 204, 255)"><b>NVCS-3000</b></font>')
CreditsGroupbox:AddLabel('made by Upio', true)

local InfoGroupbox = CreditsTab:AddRightGroupbox("About Ostium")
InfoGroupbox:AddLabel('<font color="rgb(180, 180, 180)">Version:</font> <b>2.10</b>')
InfoGroupbox:AddLabel('<font color="rgb(180, 180, 180)">Last Update:</font> <b>18:34 23/10/2025 european date</b>')
InfoGroupbox:AddDivider()
InfoGroupbox:AddButton({
    Text = "Join Our Community",
    Func = function()
        setclipboard("https://discord.gg/9UuswyPTDE")
        Library:Notify("Discord link copied to clipboard!", 3)
    end,
    Tooltip = "Join our Discord for updates and support!"
})

 AddonsTab = Window:AddTab("Addons", "plug")


AddonsTab:UpdateWarningBox({
    Title = "WARNING!",
    Text = "Dont download random addons, check if they are safe.",
    IsNormal = false, 
    Visible = true,  
    LockSize = true 
})

 AddonsGroup = AddonsTab:AddLeftGroupbox("Addons")

getgenv().Ostium = {
    Groupbox = AddonsGroup,
}

 hubFolder = "Ostium"
 addonFolder = hubFolder .. "/Addons"

if not isfolder(hubFolder) then
    makefolder(hubFolder)
end

if not isfolder(addonFolder) then
    makefolder(addonFolder)
end

 Addons = {}

for _, file in ipairs(listfiles(addonFolder)) do
    if file:sub(-4) == ".lua" or file:sub(-4) == ".txt" then
        local success, result = pcall(function()
            return loadstring(readfile(file))()
        end)
        if success then

        else
            warn("Failed to load addon: " .. file .. " - Error: " .. tostring(result))
        end
    end
end

UISettings = Window:AddTab("UI Settings", "user-round-cog")

SettingsLeftGroup = UISettings:AddLeftGroupbox("Menu Settings")

MenuVisibility = SettingsLeftGroup:AddCheckbox("MenuVisibility", {
    Text = "Show Menu",
    Default = true,
    Disabled = false,
    Tooltip = "Toggle menu visibility",
    Callback = function(Value)
        Library:Toggle(Value)
        if enableNotifications then
            Library:Notify({
                Title = "Menu Visibility",
                Description = Value and "Menu shown" or "Menu hidden",
                Time = notifyDuration,
                SoundId = notificationSoundId > 0 and notificationSoundId or nil
            })
        end
    end
})

MenuVisibility:AddKeyPicker("MenuToggleKey", {
    Default = "End",
    SyncToggleState = true,
    Mode = "Toggle",
    Text = "Menu Toggle",
    NoUI = false
})

SettingsLeftGroup:AddDivider()

SettingsLeftGroup:AddButton({
    Text = "Unload Menu",
    Func = function()
        if enableNotifications then
            Library:Notify({
                Title = "Menu Unload",
                Description = "Unloading menu...",
                Time = notifyDuration,
                SoundId = notificationSoundId > 0 and notificationSoundId or nil
            })
        end
        task.wait(0.3)
        Library:Unload()
    end,
    DoubleClick = false,
    Tooltip = "Unload the menu"
})










AppearanceGroup = UISettings:AddLeftGroupbox("Appearance")

AppearanceGroup:AddCheckbox("ShowKeybinds", {
    Text = "Show Keybinds Frame",
    Default = false,
    Disabled = false,
    Tooltip = "Toggle keybinds list visibility",
    Callback = function(Value)
        Library.KeybindFrame.Visible = Value
        if enableNotifications then
            Library:Notify({
                Title = "Keybinds Frame",
                Description = "Keybinds frame " .. (Value and "shown" or "hidden"),
                Time = notifyDuration,
                SoundId = notificationSoundId > 0 and notificationSoundId or nil
            })
        end
    end
})

SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetFolder("Ostium")
SaveManager:BuildConfigSection(UISettings)

ThemeManager:SetLibrary(Library)
ThemeManager:SetFolder("Ostium")
ThemeManager:ApplyToTab(UISettings)

local NotificationGroup = UISettings:AddRightGroupbox("Notifications")

notifyDuration = 3
enableNotifications = true
notificationSoundId = 0

soundPresets = {
    {Name = "None", Id = 0},
    {Name = "Default Notification", Id = 3023237993},
    {Name = "Android Ding", Id = 6205430632},
    {Name = "Error Buzz", Id = 5188022160},
    {Name = "Alert Alarm", Id = 1616678030}
}

NotificationGroup:AddCheckbox("EnableNotifications", {
    Text = "Enable Notifications",
    Default = true,
    Disabled = false,
    Tooltip = "Toggle whether notifications are shown for actions",
    Callback = function(Value)
        enableNotifications = Value
    end
})

NotificationGroup:AddSlider("NotifyDuration", {
    Text = "Notification Duration (s)",
    Default = 3,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Compact = true,
    Callback = function(Value)
        notifyDuration = Value
        if enableNotifications then
            Library:Notify({
                Title = "Notification Settings",
                Description = "Notification duration set to " .. Value .. " seconds",
                Time = Value,
                SoundId = notificationSoundId > 0 and notificationSoundId or nil
            })
        end
    end
})

local soundInput = NotificationGroup:AddInput("NotificationSoundId", {
    Text = "Notification Sound ID",
    Default = "0",
    Numeric = true,
    Finished = true,
    Tooltip = "Roblox sound ID for all notifications (0 for none)",
    Callback = function(Value)
        notificationSoundId = tonumber(Value) or 0
    end
})

NotificationGroup:AddDropdown("SoundPreset", {
    Text = "Sound Preset",
    Default = "None",
    Values = {"None", "Default Notification", "Android Ding", "Error Buzz", "Alert Alarm"},
    Callback = function(Value)
        for _, preset in ipairs(soundPresets) do
            if preset.Name == Value then
                notificationSoundId = preset.Id
                soundInput:SetValue(tostring(preset.Id))
                break
            end
        end
    end
})
NotificationGroup:AddButton({
    Text = "Test Notification",
    Func = function()
        Library:Notify({
            Title = "Test Notification",
            Description = "This is a test notification!",
            Time = notifyDuration,
            SoundId = notificationSoundId > 0 and notificationSoundId or nil
        })
    end
})

Library:SetWatermarkVisibility(true)

local function updateWatermark()
    local fps = 60
    local frameTimer = tick()
    local frameCounter = 0
    game:GetService("RunService").RenderStepped:Connect(function()
        frameCounter = frameCounter + 1  
        if tick() - frameTimer >= 1 then
            fps = frameCounter
            frameTimer = tick()
            frameCounter = 0
        end
        Library:SetWatermark(string.format(
            "Ostium | %d FPS | By Velocity | %d ping | v2.10",
            math.floor(fps),
            math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        ))
    end)
end

updateWatermark()
